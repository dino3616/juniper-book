<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Juniper - GraphQL Server for Rust 日本語版</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> はじめに</a></li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">2.</strong> クイックスタート</a></li><li class="chapter-item expanded "><a href="types/index.html"><strong aria-hidden="true">3.</strong> 型システム</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/objects/defining_objects.html"><strong aria-hidden="true">3.1.</strong> オブジェクトの定義</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/objects/complex_fields.html"><strong aria-hidden="true">3.1.1.</strong> 複雑なフィールド</a></li><li class="chapter-item expanded "><a href="types/objects/using_contexts.html"><strong aria-hidden="true">3.1.2.</strong> コンテキストを使う</a></li><li class="chapter-item expanded "><a href="types/objects/error_handling.html"><strong aria-hidden="true">3.1.3.</strong> エラーハンドリング</a></li></ol></li><li class="chapter-item expanded "><a href="types/other-index.html"><strong aria-hidden="true">3.2.</strong> その他の型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/enums.html"><strong aria-hidden="true">3.2.1.</strong> 列挙型</a></li><li class="chapter-item expanded "><a href="types/interfaces.html"><strong aria-hidden="true">3.2.2.</strong> インターフェイス</a></li><li class="chapter-item expanded "><a href="types/input_objects.html"><strong aria-hidden="true">3.2.3.</strong> 入力オブジェクト</a></li><li class="chapter-item expanded "><a href="types/scalars.html"><strong aria-hidden="true">3.2.4.</strong> スカラー</a></li><li class="chapter-item expanded "><a href="types/unions.html"><strong aria-hidden="true">3.2.5.</strong> ユニオン</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="schema/schemas_and_mutations.html"><strong aria-hidden="true">4.</strong> スキーマとミューテーション</a></li><li class="chapter-item expanded "><a href="servers/index.html"><strong aria-hidden="true">5.</strong> サーバーを追加する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="servers/official.html"><strong aria-hidden="true">5.1.</strong> Juniperによる連携</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="servers/warp.html"><strong aria-hidden="true">5.1.1.</strong> Warp</a></li><li class="chapter-item expanded "><a href="servers/rocket.html"><strong aria-hidden="true">5.1.2.</strong> Rocket</a></li><li class="chapter-item expanded "><a href="servers/iron.html"><strong aria-hidden="true">5.1.3.</strong> Iron</a></li><li class="chapter-item expanded "><a href="servers/hyper.html"><strong aria-hidden="true">5.1.4.</strong> Hyper</a></li></ol></li><li class="chapter-item expanded "><a href="servers/third_party.html"><strong aria-hidden="true">5.2.</strong> サードパーティとの連携</a></li></ol></li><li class="chapter-item expanded "><a href="advanced/index.html"><strong aria-hidden="true">6.</strong> 高度なトッピク</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/introspection.html"><strong aria-hidden="true">6.1.</strong> イントロスペクション</a></li><li class="chapter-item expanded "><a href="advanced/non_struct_objects.html"><strong aria-hidden="true">6.2.</strong> 非構造体オブジェクト</a></li><li class="chapter-item expanded "><a href="advanced/implicit_and_explicit_null.html"><strong aria-hidden="true">6.3.</strong> 暗黙的および明示的なNULL</a></li><li class="chapter-item expanded "><a href="advanced/objects_and_generics.html"><strong aria-hidden="true">6.4.</strong> オブジェクトとジェネリクス</a></li><li class="chapter-item expanded "><a href="advanced/multiple_ops_per_request.html"><strong aria-hidden="true">6.5.</strong> 1回のリクエストで複数の操作を行う</a></li><li class="chapter-item expanded "><a href="advanced/dataloaders.html"><strong aria-hidden="true">6.6.</strong> データローダーによるN+1問題の回避</a></li><li class="chapter-item expanded "><a href="advanced/subscriptions.html"><strong aria-hidden="true">6.7.</strong> サブスクリプション</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Juniper - GraphQL Server for Rust 日本語版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="juniper"><a class="header" href="#juniper">Juniper</a></h1>
<p>Juniper は、Rust 用の <a href="http://graphql.org">GraphQL</a> サーバーライブラリです。型安全で高速なAPIサーバーを、最小限の定型文と設定で構築できます。</p>
<p><a href="http://graphql.org">GraphQL</a>は、Facebookが開発したデータクエリ言語です。
モバイルおよびWebアプリケーションのフロントエンドにサービスを提供します。</p>
<p>Juniper は、Rust で GraphQL サーバを型安全かつ高速に記述することを可能にします。また、Rust が許す限り、GraphQL のスキーマの宣言と解決をできるだけ便利にすることを心がけています。</p>
<p>Juniper にはウェブサーバーは含まれていません。代わりに、既存のサーバーとの統合を容易にするためのビルディングブロックを提供しています。オプションで、<a href="https://hyper.rs">Hyper</a>、<a href="https://github.com/iron/iron">Iron</a>、<a href="https://rocket.rs">Rocket</a>、<a href="https://github.com/seanmonstar/warp">Warp</a>フレームワーク用の組み込み済みインテグレーションを提供し、簡単にデバッグできるように<a href="https://github.com/graphql/graphiql">Graphiql</a>も組み込まれています。</p>
<ul>
<li><a href="https://crates.io/crates/juniper">Cargo crate</a></li>
<li><a href="https://docs.rs/juniper">APIリファレンス</a></li>
</ul>
<h2 id="特徴"><a class="header" href="#特徴">特徴</a></h2>
<p>ジュニパーは、インターフェース、ユニオン、スキーマイントロスペクション、検証を含む、<a href="http://facebook.github.io/graphql">仕様</a>に準拠したGraphQLクエリ言語をフルサポートしています。
しかし、スキーマ言語はサポートしていません。</p>
<p>他の言語向けGraphQLライブラリーの例外として、Juniperはデフォルトで非NULL型を構築します。<code>Vec&lt;Episode&gt;</code> 型のフィールドは、 <code>[Episode!]!</code> に変換されます。例えば <code>[Episode]</code> に対応する Rust 型は <code>Option&lt;Vec&lt;Option&lt;Episode&gt;&gt;</code> です。</p>
<h2 id="インテグレーション"><a class="header" href="#インテグレーション">インテグレーション</a></h2>
<h3 id="データ型"><a class="header" href="#データ型">データ型</a></h3>
<p>Juniperは、スキーマの構築を容易にするために、非常に一般的なRustクレートを自動的に統合しています。これらのクレートの型は、スキーマの中で自動的に使用できるようになります。</p>
<ul>
<li><a href="https://crates.io/crates/uuid">uuid</a></li>
<li><a href="https://crates.io/crates/url">url</a></li>
<li><a href="https://crates.io/crates/chrono">chrono</a></li>
<li><a href="https://crates.io/crates/bson">bson</a></li>
</ul>
<h3 id="ウェブフレームワーク"><a class="header" href="#ウェブフレームワーク">ウェブフレームワーク</a></h3>
<ul>
<li><a href="https://hyper.rs">hyper</a></li>
<li><a href="https://rocket.rs">rocket</a></li>
<li><a href="https://github.com/iron/iron">iron</a></li>
<li><a href="https://github.com/seanmonstar/warp">warp</a></li>
</ul>
<h2 id="api-の安定性"><a class="header" href="#api-の安定性">API の安定性</a></h2>
<p>Juniperはまだ1.0に到達していないため、APIが不安定になることが予想されます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="クイックスタート"><a class="header" href="#クイックスタート">クイックスタート</a></h1>
<p>このページでは、Juniperのコンセプトを簡単に紹介します。</p>
<p>Juniperは、GraphQLのスキーマを定義する際に<a href="https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/">コードファースト方式</a>に従っています。<a href="https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/">スキーマファースト方式</a>を採用したい場合は、スキーマファイルからコードを生成する<a href="https://github.com/davidpdrsn/juniper-from-schema">juniper-from-schema</a>を検討してください。</p>
<h2 id="インストール"><a class="header" href="#インストール">インストール</a></h2>
<pre><code class="language-toml">[dependencies]
juniper = &quot;0.15&quot;
</code></pre>
<h2 id="スキーマの例"><a class="header" href="#スキーマの例">スキーマの例</a></h2>
<p>単純な列挙型や構造体をGraphQLとして公開するには、カスタムの<code>derive</code>属性を追加するだけでよいのです。Juniperでは、<code>Option&lt;T&gt;</code>、<code>Vec&lt;T&gt;</code>、<code>Box&lt;T&gt;</code>、<code>String</code>、<code>f64</code>、<code>i32</code>、参照、スライスなど、GraphQL機能に自然に対応するRustの基本型をサポートしています。</p>
<p>より高度なマッピングのために、Juniperは、Rust型をGraphQLスキーマにマッピングするための複数のマクロを提供しています。最も重要なのは <a href="https://docs.rs/juniper/latest/juniper/macro.graphql_object.html">graphql_object</a> 手続き型マクロで、 <code>Query</code> と <code>Mutation</code> のルートで使用するリゾルバを持つオブジェクトを宣言するために使用されます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">extern crate juniper;
</span><span class="boring">use std::fmt::Display;
</span>use juniper::{
    graphql_object, EmptySubscription, FieldResult, GraphQLEnum, 
    GraphQLInputObject, GraphQLObject, ScalarValue,
};
<span class="boring">
</span><span class="boring">struct DatabasePool;
</span><span class="boring">impl DatabasePool {
</span><span class="boring">    fn get_connection(&amp;self) -&gt; FieldResult&lt;DatabasePool&gt; { Ok(DatabasePool) }
</span><span class="boring">    fn find_human(&amp;self, _id: &amp;str) -&gt; FieldResult&lt;Human&gt; { Err(&quot;&quot;)? }
</span><span class="boring">    fn insert_human(&amp;self, _human: &amp;NewHuman) -&gt; FieldResult&lt;Human&gt; { Err(&quot;&quot;)? }
</span><span class="boring">}
</span>
#[derive(GraphQLEnum)]
enum Episode {
    NewHope,
    Empire,
    Jedi,
}

#[derive(GraphQLObject)]
#[graphql(description = &quot;スター・ウォーズの世界に登場する人物&quot;)]
struct Human {
    id: String,
    name: String,
    appears_in: Vec&lt;Episode&gt;,
    home_planet: String,
}

// GraphQLの入力オブジェクトをマッピングするためのカスタムderiveも用意されています.

#[derive(GraphQLInputObject)]
#[graphql(description = &quot;スター・ウォーズの世界に登場する人物&quot;)]
struct NewHuman {
    name: String,
    appears_in: Vec&lt;Episode&gt;,
    home_planet: String,
}

// ここで、オブジェクトマクロを使用して、リゾルバを持つルートQueryとMutationの型を作成します.
// オブジェクトは、データベースプールのような共有状態にアクセスするためのコンテキストを持つことができます.

struct Context {
    // ここでは、実際のデータベースプールを使用してください.
    pool: DatabasePool,
}

// Juniperで使えるコンテキストにするために、マーカートレイトを実装する必要があります。
impl juniper::Context for Context {}

struct Query;

#[graphql_object(
    // ここでは、オブジェクトのコンテキストタイプを指定します.
    // コンテキストにアクセスする必要があるすべての型でこれを行う必要があります.
    context = Context,
)]
impl Query {
    fn apiVersion() -&gt; &amp;'static str {
        &quot;1.0&quot;
    }

    // リゾルバへの引数は、単純な型か入力オブジェクトのいずれかです.
    // コンテキストにアクセスするために、Context型への参照である引数を指定します.
    // Juniperは、ここで自動的に正しいコンテキストを注入します.
    fn human(context: &amp;Context, id: String) -&gt; FieldResult&lt;Human&gt; {
        // DB接続を取得します.
        let connection = context.pool.get_connection()?;
        // DBクエリを実行します.
        // エラーを伝播させるために `?` が使われていることに注意してください.
        let human = connection.find_human(&amp;id)?;
        // 結果を返します.
        Ok(human)
    }
}

// 次に、Mutationタイプについても同じことを行います.

struct Mutation;

#[graphql_object(
    context = Context,
    // もし、オブジェクト定義のどこかで明示的に ScalarValue パラメトリを使用する必要がある場合 (ここでの FieldResult のように)、
    // そのための明示的な型パラメータを宣言して、それを指定すればよいでしょう.
    scalar = S: ScalarValue + Display,
)]
impl Mutation {
    fn createHuman&lt;S: ScalarValue + Display&gt;(context: &amp;Context, new_human: NewHuman) -&gt; FieldResult&lt;Human, S&gt; {
        let db = context.pool.get_connection().map_err(|e| e.map_scalar_value())?;
        let human: Human = db.insert_human(&amp;new_human).map_err(|e| e.map_scalar_value())?;
        Ok(human)
    }
}

// ルートスキーマは、Query、Mutation、Subscriptionから構成されます.
// RootNodeに対して、リクエストクエリを実行することができます.
type Schema = juniper::RootNode&lt;'static, Query, Mutation, EmptySubscription&lt;Context&gt;&gt;;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">  let _ = Schema::new(Query, Mutation{}, EmptySubscription::new());
</span><span class="boring">}
</span></code></pre></pre>
<p>これで、GraphQLサーバーのための非常にシンプルで機能的なスキーマが完成しました。</p>
<p>実際にスキーマを提供するためには、私たちの様々な<a href="./servers/index.html">サーバー統合</a>のガイドを参照してください。</p>
<p>Juniperは、サーバーを必要とせず、特定のトランスポートやシリアライズ形式にも依存しない、様々な文脈で利用できるライブラリです。クエリの結果を得るために、executorを直接呼び出すことができます。</p>
<h2 id="executor"><a class="header" href="#executor">Executor</a></h2>
<p>GraphQLクエリを実行するには、<code>juniper::execute</code>を直接呼び出すことができます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// マクロにアクセスできないため、2018年版のため必要なだけです.
</span><span class="boring">#[macro_use] extern crate juniper;
</span>use juniper::{
    graphql_object, EmptyMutation, EmptySubscription, FieldResult, 
    GraphQLEnum, Variables, graphql_value,
};

#[derive(GraphQLEnum, Clone, Copy)]
enum Episode {
    NewHope,
    Empire,
    Jedi,
}

// 任意のコンテキストデータ.
struct Ctx(Episode);

impl juniper::Context for Ctx {}

struct Query;

#[graphql_object(context = Ctx)]
impl Query {
    fn favoriteEpisode(context: &amp;Ctx) -&gt; FieldResult&lt;Episode&gt; {
        Ok(context.0)
    }
}

// ルートスキーマは、Query、Mutation、Subscriptionから構成されます.
// RootNodeに対して、リクエストクエリを実行することができます.
type Schema = juniper::RootNode&lt;'static, Query, EmptyMutation&lt;Ctx&gt;, EmptySubscription&lt;Ctx&gt;&gt;;

fn main() {
    // コンテキストオブジェクトを作成します.
    let ctx = Ctx(Episode::NewHope);

    // executorを実行します.
    let (res, _errors) = juniper::execute_sync(
        &quot;query { favoriteEpisode }&quot;,
        None,
        &amp;Schema::new(Query, EmptyMutation::new(), EmptySubscription::new()),
        &amp;Variables::new(),
        &amp;ctx,
    ).unwrap();

    // 値が一致していることを確認します.
    assert_eq!(
        res,
        graphql_value!({
            &quot;favoriteEpisode&quot;: &quot;NEW_HOPE&quot;,
        })
    );
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="型システム"><a class="header" href="#型システム">型システム</a></h1>
<p>juniperを使用する際の作業のほとんどは、GraphQLの型システムとアプリケーションが使用するRustの型とのマッピングから構成されます。</p>
<p>juniperは、この作業をできるだけ楽にするために、いくつかの便利な抽象化機能を提供しています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="オブジェクトの定義"><a class="header" href="#オブジェクトの定義">オブジェクトの定義</a></h1>
<p>Rust のどの型も GraphQL オブジェクトとして公開することができますが、最も一般的なのは構造体です。</p>
<p>JuniperでGraphQLオブジェクトを作成するには、2つの方法があります。
単純な構造体を公開したい場合、最も簡単な方法は、カスタムの<code>derive</code>属性があります。
もうひとつの方法は、<a href="types/objects/complex_fields.html">複雑なフィールド</a>の章で説明します。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::GraphQLObject;
</span>#[derive(GraphQLObject)]
struct Person {
    name: String,
    age: i32,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>これは <code>Person</code> という名前の GraphQL オブジェクトタイプを作成し、2つのフィールドを持つようにします。<code>name</code> は <code>String!</code> 型で、<code>age</code> は <code>Int!</code> 型です。Rustの型システムにより、デフォルトではすべて非NULLでエクスポートされます。もし、NULLにできるフィールドが必要な場合は、 <code>Option&lt;T&gt;</code> を使用することができます。</p>
<p>GraphQLがセルフドキュメントであることを利用して、型やフィールドに説明を加えるべきでしょう。Juniperは、関連するdocコメントを自動的にGraphQLの記述として使用します。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::GraphQLObject;
</span>#[derive(GraphQLObject)]
/// 個人に関する情報
struct Person {
    /// 姓名
    name: String,
    /// 年齢
    age: i32,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>docコメントを持たないオブジェクトやフィールドは、代わりに <code>graphql</code> 属性で <code>description</code> を設定することができます。
以下の例は、上記と同等です。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::GraphQLObject;
</span>#[derive(GraphQLObject)]
#[graphql(description = &quot;個人に関する情報&quot;)]
struct Person {
    #[graphql(description = &quot;姓名&quot;)]
    name: String,
    #[graphql(description = &quot;年齢&quot;)]
    age: i32,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><code>graphql</code> 属性で設定した記述は、Rust のドキュメントコメントよりも優先されます。これにより、内部の Rust ドキュメントと外部の GraphQL ドキュメントを区別することができます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::GraphQLObject;
</span>#[derive(GraphQLObject)]
#[graphql(description = &quot;この記述は、GraphQLに表示される&quot;)]
/// この記述は、RustDocに表示されます.
struct Person {
    #[graphql(description = &quot;この記述は、GraphQLに表示される&quot;)]
    /// この記述は、RustDocに表示されます.
    name: String,
    /// この記述は、RustDocとGraphQLの両方で表示されます.
    age: i32,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="関係性"><a class="header" href="#関係性">関係性</a></h2>
<p>カスタム<code>derive</code>属性は、以下のような状況下でのみ使用することができます。</p>
<ul>
<li>アノテーションされた型は <code>struct</code> である。</li>
<li>すべての構造体フィールドは、以下のいずれかである。
<ul>
<li>プリミティブ型(<code>i32</code>, <code>f64</code>, <code>bool</code>, <code>String</code>, <code>juniper::ID</code>)</li>
<li>有効なカスタムGraphQLタイプ(例えば、この属性でマークされた別の構造体)</li>
<li>上記のいずれかを含むコンテナまたは参照(例えば、<code>Vec&lt;T&gt;</code>、<code>Box&lt;T&gt;</code>、<code>Option&lt;T&gt;</code> など)</li>
</ul>
</li>
</ul>
<p>オブジェクト間のリレーションシップ構築の意味を見てみましょう。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::GraphQLObject;
</span>#[derive(GraphQLObject)]
struct Person {
    name: String,
    age: i32,
}

#[derive(GraphQLObject)]
struct House {
    address: Option&lt;String&gt;, // 文字列に変換される(NULL可).
    inhabitants: Vec&lt;Person&gt;, // [Person!]に変換されます.
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><code>Person</code> は有効な GraphQL 型なので、構造体の中に <code>Vec&lt;Person&gt;</code> を入れても、自動的に NULL でない <code>Person</code> オブジェクトのリストに変換されます。</p>
<h2 id="フィールド名の変更"><a class="header" href="#フィールド名の変更">フィールド名の変更</a></h2>
<p>デフォルトでは、構造体フィールドはRustの標準的な命名規則である <code>snake_case</code> から、GraphQLの <code>camelCase</code> に変換されます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::GraphQLObject;
</span>#[derive(GraphQLObject)]
struct Person {
    first_name: String, // GraphQLスキーマではfirstNameとして公開されます.
    last_name: String, // lastName として公開されます.
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>個々の構造体フィールドに <code>graphql</code> 属性を指定することで、名前をオーバーライドすることができます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::GraphQLObject;
</span>#[derive(GraphQLObject)]
struct Person {
    name: String,
    age: i32,
    #[graphql(name = &quot;websiteURL&quot;)]
    website_url: Option&lt;String&gt;, // スキーマで websiteUrl として公開されるようになりました.
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>または、構造体のすべてのフィールドに対して、異なるリネームポリシーを設定します。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::GraphQLObject;
</span>#[derive(GraphQLObject)]
#[graphql(rename_all = &quot;none&quot;)] // リネームを無効にします.
struct Person {
    name: String,
    age: i32,
    website_url: Option&lt;String&gt;, // スキーマで website_url として公開されるようになりました.
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="非推奨のフィールド"><a class="header" href="#非推奨のフィールド">非推奨のフィールド</a></h2>
<p>フィールドを非推奨にするには、<code>graphql</code> 属性で非推奨の理由を指定します。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::GraphQLObject;
</span>#[derive(GraphQLObject)]
struct Person {
    name: String,
    age: i32,
    #[graphql(deprecated = &quot;代わりに名前フィールドを使用してください&quot;)]
    first_name: String,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><code>name</code>, <code>description</code>, <code>deprecation</code> の各引数は、もちろん組み合わせることができます。オブジェクトフィールドとenum値のみ非推奨とすることができるなど、GraphQL仕様の制限事項がまだ適用されます。</p>
<h2 id="フィールドを無視する"><a class="header" href="#フィールドを無視する">フィールドを無視する</a></h2>
<p>デフォルトでは、<code>GraphQLObject</code> のすべてのフィールドが生成される GraphQL 型に含まれます。特定のフィールドを含めないようにするには、そのフィールドに <code>#[graphql(ignore)]</code> というアノテーションを付けます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::GraphQLObject;
</span>#[derive(GraphQLObject)]
struct Person {
    name: String,
    age: i32,
    #[graphql(ignore)]
<span class="boring">    #[allow(dead_code)]
</span>    password_hash: String, // GraphQLからの問い合わせや変更はできない
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="複雑なフィールド"><a class="header" href="#複雑なフィールド">複雑なフィールド</a></h1>
<p>もし、計算フィールドや循環構造を含む構造体を直接GraphQLにマッピングできない場合は、より強力なツールである <code>#[graphql_object]</code> 手続き型マクロを使用する必要があります。このマクロは、Rust の <code>impl</code> ブロックで GraphQL のオブジェクトフィールドを定義することができます。
GraphQL フィールドはデフォルトでこの <code>impl</code> ブロックに定義されることに注意してください。もし、構造体に通常のメソッドを定義したい場合は、別の <code>impl</code> ブロックで定義するか、 <code>#[graphql(ignore)]</code> 属性でマークして、マクロで省略できるようにしなければなりません。
前章の例の続きで、マクロを使用して <code>Person</code> を定義する方法を説明します。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::graphql_object;
</span><span class="boring">
</span>struct Person {
    name: String,
    age: i32,
}

#[graphql_object]
impl Person {
    fn name(&amp;self) -&gt; &amp;str {
        self.name.as_str()
    }

    fn age(&amp;self) -&gt; i32 {
        self.age
    }

    #[graphql(ignore)]
    pub fn hidden_from_graphql(&amp;self) {
        // [...]
    }
}

impl Person {
    pub fn hidden_from_graphql2(&amp;self) {
        // [...]
    }
}
<span class="boring">
</span><span class="boring">fn main() { }
</span></code></pre></pre>
<p>これは少し冗長ではありますが、フィールドリゾルバにあらゆる種類の関数を書くことができます。この構文では、フィールドは引数を取ることもできます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::{graphql_object, GraphQLObject};
</span><span class="boring">
</span>#[derive(GraphQLObject)]
struct Person {
    name: String,
    age: i32,
}

struct House {
    inhabitants: Vec&lt;Person&gt;,
}

#[graphql_object]
impl House {
    // フィールド inhabitantWithName(name) を作成し、nullable の Person を返します.
    fn inhabitant_with_name(&amp;self, name: String) -&gt; Option&lt;&amp;Person&gt; {
        self.inhabitants.iter().find(|p| p.name == name)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>データベース接続や認証情報などのグローバルなデータにアクセスするには、<code>context</code> を使用します。これについては、次の章を参照してください。<a href="types/objects/using_contexts.html">コンテキストを使う</a> をご覧ください。</p>
<h2 id="説明名前の変更および非推奨"><a class="header" href="#説明名前の変更および非推奨">説明、名前の変更、および非推奨</a></h2>
<p><code>derive</code> 属性と同様に、フィールド名は <code>snake_case</code> から <code>camelCase</code> に変換されます。変換をオーバーライドしたい場合は、フィールド名を変更するだけです。また、型名はエイリアスで変更することができます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::graphql_object;
</span><span class="boring">
</span>struct Person;

/// Docコメントは、GraphQLの記述として使用されます.
#[graphql_object(
    // この属性で、型の公開GraphQL名を変更することができます.
    name = &quot;PersonObject&quot;,

    // ここで説明を指定することもでき、その場合は上書きされます.
    description = &quot;...&quot;,
)]
impl Person {
    /// フィールドのdocコメントは、GraphQLにも使用されます.
    #[graphql(
        // もしくは、ここで説明を記述することもできます.
        description = &quot;...&quot;,
    )]
    fn doc_comment(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }

    // 必要に応じて、フィールドの名前を変更することもできます.
    #[graphql(name = &quot;myCustomFieldName&quot;)]
    fn renamed_field() -&gt; bool {
        true
    }

    // 非推奨事項期待通りに動作します.
    // Rustの標準的な構文とカスタムderiveの両方を受け入れることができます.
    #[deprecated(note = &quot;...&quot;)]
    fn deprecated_standard() -&gt; bool {
        false
    }

    #[graphql(deprecated = &quot;...&quot;)]
    fn deprecated_graphql() -&gt; bool {
        true
    }
}
<span class="boring">
</span><span class="boring">fn main() { }
</span></code></pre></pre>
<p>あるいは、<code>impl</code>ブロックのすべてのフィールドに対して、異なるリネームポリシーを提供します。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::graphql_object;
</span>struct Person;

#[graphql_object(rename_all = &quot;none&quot;)] // リネームを無効にする.
impl Person {
    // スキーマで `renamed_field` として公開されるようになりました.
    fn renamed_field() -&gt; bool {
        true
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="引数のカスタマイズ"><a class="header" href="#引数のカスタマイズ">引数のカスタマイズ</a></h2>
<p>メソッドフィールドの引数もカスタマイズすることができます。</p>
<p>それらはカスタム記述とデフォルト値を持つことができます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::graphql_object;
</span><span class="boring">
</span>struct Person {}

#[graphql_object]
impl Person {
    fn field1(
        &amp;self,
        #[graphql(
            // また、必要に応じて引数の名前を変更することができます.
            name = &quot;arg&quot;,
            // 存在しない場合に注入されるデフォルト値デフォルト値を設定します.
            // デフォルトは、関数呼び出しなどを含む有効なRust式であれば、どのようなものでもよい.
            default = true,
            // 説明文を設定します.
            description = &quot;The first argument...&quot;
        )]
        arg1: bool,
        // デフォルト値が指定されていない場合は Default::default() の値が使用される。
        #[graphql(default)]
        arg2: i32,
    ) -&gt; String {
        format!(&quot;{} {}&quot;, arg1, arg2)
    }
}
<span class="boring">
</span><span class="boring">fn main() { }
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="コンテキストを使う"><a class="header" href="#コンテキストを使う">コンテキストを使う</a></h1>
<p>コンテキスト型は、Juniper の機能で、フィールドリゾルバがグローバルデータ (最も一般的なのはデータベース接続や認証情報) にアクセスできるようにするものです。コンテキストは通常、context factory から作成されます。そのため、<a href="types/objects/../../servers/iron.html">Iron</a> や <a href="types/objects/../../servers/rocket.html">Rocket</a> のドキュメントをチェックしてみてください。</p>
<p>この章では、コンテキストタイプを定義し、それをフィールドリゾルバで使用する方法を説明します。例えば、<code>HashMap</code> の中に簡単なユーザーデータベースがあるとします。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">
</span>struct Database {
    users: HashMap&lt;i32, User&gt;,
}

struct User {
    id: i32,
    name: String,
    friend_ids: Vec&lt;i32&gt;,
}
<span class="boring">
</span><span class="boring">fn main() { }
</span></code></pre></pre>
<p><code>User</code> オブジェクトのリストを返す <code>friends</code> フィールドを <code>User</code> に設けたいと思います。
しかし、そのようなフィールドを作成するためには、データベースに問い合わせる必要があります。</p>
<p>これを解決するために、<code>Database</code> を有効なコンテキストタイプとしてマークして、user オブジェクトに割り当てます。</p>
<p>コンテキストにアクセスするには、その型に指定した <code>Context</code> と同じ型を持つ引数を指定する必要があります。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">use juniper::graphql_object;
</span><span class="boring">
</span>// この構造体は、私たちのコンテキストを表します.
struct Database {
    users: HashMap&lt;i32, User&gt;,
}

// データベースをJuniperの有効なコンテキストタイプとしてマークします.
impl juniper::Context for Database {}

struct User {
    id: i32,
    name: String,
    friend_ids: Vec&lt;i32&gt;,
}

// UserのコンテキストタイプにDatabaseを指定する.
#[graphql_object(context = Database)]
impl User {
    // コンテキストの種類を引数に指定して、コンテキストを注入する.
    // Note: 
    //   - 型は参照でなければなりません.
    //   - 引数の名前は `context` であるべきです.
    fn friends&lt;'db&gt;(&amp;self, context: &amp;'db Database) -&gt; Vec&lt;&amp;'db User&gt; {
        // データベースを利用してユーザーを検索する.
        self.friend_ids.iter()
            .map(|id| context.users.get(id).expect(&quot;Could not find user with ID&quot;))
            .collect()
    }

    fn name(&amp;self) -&gt; &amp;str { 
        self.name.as_str() 
    }

    fn id(&amp;self) -&gt; i32 { 
        self.id 
    }
}
<span class="boring">
</span><span class="boring">fn main() { }
</span></code></pre></pre>
<p>コンテキストへの不変の参照を得るだけなので、実行内容に変更を加えたい場合は、 <code>RwLock</code> や <code>RefCell</code> などの <a href="https://doc.rust-lang.org/book/first-edition/mutability.html#interior-vs-exterior-mutability">可変なイテレータ</a> を使用する必要があります。</p>
<h2 id="可変参照の扱い"><a class="header" href="#可変参照の扱い">可変参照の扱い</a></h2>
<p>並行フィールド解決が行われる可能性があるため、コンテキストをミュータブル参照で指定することはできません。もし、コンテキストにミュータブル参照によるアクセスが必要なものがあれば、そのために <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">可変なイテレータ</a> を活用する必要があります。</p>
<p>例えば、<a href="https://en.wikipedia.org/wiki/Work_stealing">work stealing</a> (<code>tokio</code> など) で非同期ランタイムを使用する場合、明らかにスレッドセーフが必要ですが、それに対応する非同期バージョンの <code>RwLock</code> を使用する必要があります。</p>
<p>非同期解決を使用しない場合は、 <code>tokio::sync::RwLock</code> を <code>std::sync::RwLock</code> (または類似のもの) に置き換えてください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="エラーハンドリング"><a class="header" href="#エラーハンドリング">エラーハンドリング</a></h1>
<p>GraphQLにおけるエラー処理は、複数の方法で行うことができます。以下では、2つの異なるエラー処理モデルについて説明します。フィールドの結果とGraphQLスキーマの裏付けとなるエラーです。それぞれのアプローチには利点があります。正しいエラー処理方法を選択することは、アプリケーションの要件に依存します。両方のアプローチを調査することは有益です。</p>
<h2 id="フィールドの結果"><a class="header" href="#フィールドの結果">フィールドの結果</a></h2>
<p>Rustはエラーを処理する方法を2つ提供しています。回復可能なエラーには <code>Result&lt;T, E&gt;</code> を、回復不可能なエラーには <code>panic!</code> を使用します。Juniperはパニックに対して何もしません。パニックは周囲のフレームワークにバブルアップされ、うまくいけばそこで処理されます。</p>
<p>回復可能なエラーの場合、Juniperは組み込みの <code>Result</code> 型でうまく動作し、 <code>?</code> 演算子を使用することで、一般的に期待通りの動作をします。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>use std::{
    str,
    path::PathBuf,
    fs::{File},
    io::{Read},
};
use juniper::{graphql_object, FieldResult};

struct Example {
    filename: PathBuf,
}

#[graphql_object]
impl Example {
    fn contents(&amp;self) -&gt; FieldResult&lt;String&gt; {
        let mut file = File::open(&amp;self.filename)?;
        let mut contents = String::new();
        file.read_to_string(&amp;mut contents)?;
        Ok(contents)
    }

    fn foo() -&gt; FieldResult&lt;Option&lt;String&gt;&gt; {
        // 一部無効なバイトがあります.
        let invalid = vec![128, 223];

        Ok(Some(str::from_utf8(&amp;invalid)?.to_string()))
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><code>FieldResult&lt;T&gt;</code> は <code>Result&lt;T, FieldError&gt;</code> のエイリアスで、すべてのフィールドが返さなければならないエラータイプです。演算子 <code>?</code> や <code>try!</code> マクロを使用すると、 <code>Display</code> トレイトを実装した型 (世の中のほとんどのエラータイプ) は、それらのエラーが自動的に <code>FieldError</code> に変換されます。</p>
<h2 id="エラーペイロードnullおよび部分エラー"><a class="header" href="#エラーペイロードnullおよび部分エラー">エラーペイロード、NULL、および部分エラー</a></h2>
<p>Juniperのエラー動作は、<a href="https://spec.graphql.org/June2018/#sec-Errors-and-Non-Nullability">GraphQL仕様</a>に準拠しています。</p>
<p>フィールドがエラーを返すと、フィールドの結果は <code>null</code> に置き換えられ、レスポンスのトップレベルに <code>errors</code> オブジェクトが追加で作成され、実行が再開されます。例えば、先ほどの例と以下のようなクエリの場合、</p>
<pre><code class="language-graphql">{
  example {
    contents
    foo
  }
}
</code></pre>
<p>もし <code>str::from_utf8</code> が <code>std::str::Utf8Error</code> を発生させた場合は、以下のような結果が返ります。</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;example&quot;: {
      contents: &quot;&lt;Contents of the file&gt;&quot;,
      foo: null
    }
  },
  &quot;errors&quot;: [
    &quot;message&quot;: &quot;invalid utf-8 sequence of 2 bytes from index 0&quot;,
    &quot;locations&quot;: [{ &quot;line&quot;: 2, &quot;column&quot;: 4 }])
  ]
}
</code></pre>
<p>上記の例のように、NULL でないフィールドからエラーが返された場合、 <code>null</code> 値は最初に NULL にできる親フィールドまで伝搬され、NULL にできるフィールドがない場合はルートの <code>data</code> オブジェクトに伝搬されます。</p>
<p>例えば、以下のようなクエリの場合です。</p>
<pre><code class="language-graphql">{
  example {
    contents
  }
}
</code></pre>
<p>上記の <code>File::open()</code> が <code>std::io::ErrorKind::PermissionDenied</code> を返した場合、以下のような結果が得られます。</p>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    &quot;message&quot;: &quot;Permission denied (os error 13)&quot;,
    &quot;locations&quot;: [{ &quot;line&quot;: 2, &quot;column&quot;: 4 }])
  ]
}
</code></pre>
<h3 id="構造化されたエラー"><a class="header" href="#構造化されたエラー">構造化されたエラー</a></h3>
<p>時には、追加の構造化されたエラー情報をクライアントに返すことが望ましい場合があります。これは、<a href="https://docs.rs/juniper/latest/juniper/trait.IntoFieldError.html"><code>IntoFieldError</code></a> を実装することで実現可能です。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[macro_use] extern crate juniper;
</span><span class="boring">use juniper::{graphql_object, FieldError, IntoFieldError, ScalarValue};
</span><span class="boring">
</span>enum CustomError {
    WhateverNotSet,
}

impl&lt;S: ScalarValue&gt; IntoFieldError&lt;S&gt; for CustomError {
    fn into_field_error(self) -&gt; FieldError&lt;S&gt; {
        match self {
            CustomError::WhateverNotSet =&gt; FieldError::new(
                &quot;Whatever does not exist&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;NO_WHATEVER&quot;
                }),
            ),
        }
    }
}

struct Example {
    whatever: Option&lt;bool&gt;,
}

#[graphql_object]
impl Example {
    fn whatever(&amp;self) -&gt; Result&lt;bool, CustomError&gt; {
        if let Some(value) = self.whatever {
            return Ok(value);
        }
        Err(CustomError::WhateverNotSet)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>指定された構造化エラー情報は、<a href="https://facebook.github.io/graphql/June2018/#sec-Errors"><code>extensions</code></a>キーに含まれます。</p>
<pre><code class="language-json">{
  &quot;errors&quot;: [{
    &quot;message&quot;: &quot;Whatever does not exist&quot;,
    &quot;locations&quot;: [{&quot;line&quot;: 2, &quot;column&quot;: 4}],
    &quot;extensions&quot;: {
      &quot;type&quot;: &quot;NO_WHATEVER&quot;
    }
  }]
}
</code></pre>
<h2 id="graphqlのスキーマに裏付けられたエラー"><a class="header" href="#graphqlのスキーマに裏付けられたエラー">GraphQLのスキーマに裏付けられたエラー</a></h2>
<p>Rustのエラーのモデルは、GraphQLに適応することができます。Rust のパニックは <code>FieldError</code> に似ています。クエリ全体が中断され、(エラー関連情報を除いて)何も取り出せなくなります。</p>
<p>すべてのエラーがこのような厳密な処理を必要とするわけではありません。回復可能なエラーや部分的なエラーは、クライアントがインテリジェントに処理できるように GraphQL スキーマに入れることができます。</p>
<p>このアプローチを実装するには、すべてのエラーを2つのエラークラスに分割する必要があります。</p>
<ul>
<li>ユーザーが修正できないクリティカルなエラー(例：データベースエラー)</li>
<li>ユーザが修正可能な回復可能エラー(例：無効な入力データ)</li>
</ul>
<p>クリティカルなエラーは、リゾルバから <code>FieldErrors</code> (前のセクションで説明) として返される。非クリティカルなエラーは GraphQL スキーマの一部であり、クライアントによって優雅に処理することができます。Rustと同様に、GraphQLでもユニオンを使った同様のエラーモデルが可能です（Unionsを参照）。</p>
<h3 id="単純な入力検証の例"><a class="header" href="#単純な入力検証の例">単純な入力検証の例</a></h3>
<p>この例では、基本的な入力検証を GraphQL タイプで実装しています。問題のあるフィールド名を特定するために文字列が使用されています。特定のフィールドに対するエラーも文字列として返されます。この例では、文字列はサーバーサイドでローカライズされたエラーメッセージを含んでいます。しかし、一意の文字列識別子を返し、クライアントがローカライズされた文字列をユーザーに提示するようにすることも可能です。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::{graphql_object, GraphQLObject, GraphQLUnion};
</span><span class="boring">
</span>#[derive(GraphQLObject)]
pub struct Item {
    name: String,
    quantity: i32,
}

#[derive(GraphQLObject)]
pub struct ValidationError {
    field: String,
    message: String,
}

#[derive(GraphQLObject)]
pub struct ValidationErrors {
    errors: Vec&lt;ValidationError&gt;,
}

#[derive(GraphQLUnion)]
pub enum GraphQLResult {
    Ok(Item),
    Err(ValidationErrors),
}

pub struct Mutation;

#[graphql_object]
impl Mutation {
    fn addItem(&amp;self, name: String, quantity: i32) -&gt; GraphQLResult {
        let mut errors = Vec::new();

        if !(10 &lt;= name.len() &amp;&amp; name.len() &lt;= 100) {
            errors.push(ValidationError {
                field: &quot;name&quot;.to_string(),
                message: &quot;between 10 and 100&quot;.to_string()
            });
        }

        if !(1 &lt;= quantity &amp;&amp; quantity &lt;= 10) {
            errors.push(ValidationError {
                field: &quot;quantity&quot;.to_string(),
                message: &quot;between 1 and 10&quot;.to_string()
            });
        }

        if errors.is_empty() {
            GraphQLResult::Ok(Item { name, quantity })
        } else {
            GraphQLResult::Err(ValidationErrors { errors })
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>各関数は異なる戻り値の型を持ち、入力パラメータに応じて新しい結果型を必要とする場合があります。例えば、ユーザーを追加する場合は、<code>Ok(Item)</code>の代わりに <code>Ok(User)</code> というバリアントを含む新しい結果型を必要とします。</p>
<p>クライアントは、以下の例に示すように、変異のリクエストを送信し、その結果のエラーを処理することができます。</p>
<pre><code class="language-graphql">{
  mutation {
    addItem(name: &quot;&quot;, quantity: 0) {
      ... on Item {
        name
      }
      ... on ValidationErrors {
        errors {
          field
          message
        }
      }
    }
  }
}
</code></pre>
<p>この方法の有用な副次的効果は、部分的に成功したクエリーまたはミューテーションを持つことです。あるリゾルバーが失敗しても、成功したリゾルバーの結果は破棄されません。</p>
<h3 id="複雑な入力検証の例"><a class="header" href="#複雑な入力検証の例">複雑な入力検証の例</a></h3>
<p>文字列を使ってエラーを伝える代わりに、GraphQLの型システムを使って、より正確にエラーを記述することが可能です。</p>
<p>誤りやすい入力変数ごとに、GraphQLオブジェクトのフィールドが作成されます。そのフィールドは、その特定のフィールドに対するバリデーションが失敗した場合に設定されます。必要な型の数が以前より大幅に増えたため、繰り返しを減らすために何らかのコード生成が必要になると思われます。各リゾルバ関数はカスタム <code>ValidationResult</code> を持ち、その関数が提供するフィールドのみを含みます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::{graphql_object, GraphQLObject, GraphQLUnion};
</span><span class="boring">
</span>#[derive(GraphQLObject)]
pub struct Item {
    name: String,
    quantity: i32,
}

#[derive(GraphQLObject)]
pub struct ValidationError {
    name: Option&lt;String&gt;,
    quantity: Option&lt;String&gt;,
}

#[derive(GraphQLUnion)]
pub enum GraphQLResult {
    Ok(Item),
    Err(ValidationError),
}

pub struct Mutation;

#[graphql_object]
impl Mutation {
    fn addItem(&amp;self, name: String, quantity: i32) -&gt; GraphQLResult {
        let mut error = ValidationError {
            name: None,
            quantity: None,
        };

        if !(10 &lt;= name.len() &amp;&amp; name.len() &lt;= 100) {
            error.name = Some(&quot;between 10 and 100&quot;.to_string());
        }

        if !(1 &lt;= quantity &amp;&amp; quantity &lt;= 10) {
            error.quantity = Some(&quot;between 1 and 10&quot;.to_string());
        }

        if error.name.is_none() &amp;&amp; error.quantity.is_none() {
            GraphQLResult::Ok(Item { name, quantity })
        } else {
            GraphQLResult::Err(error)
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<pre><code class="language-graphql">{
  mutation {
    addItem {
      ... on Item {
        name
      }
      ... on ValidationErrorsItem {
        name
        quantity
      }
    }
  }
}
</code></pre>
<p>期待されるエラーはクエリ内部で直接処理されます。さらに、重要でないエラーはすべて、サーバとクライアントの両方が事前に知っています。</p>
<h3 id="重大なエラーを含む入力検証の例"><a class="header" href="#重大なエラーを含む入力検証の例">重大なエラーを含む入力検証の例</a></h3>
<p>これまでの例では、ノンクリティカルエラーしか含まれていませんでした。GraphQLスキーマの内部でエラーを提供することで、予期せぬクリティカルエラーが発生したときに、それを返すことができます。</p>
<p>以下の例では、理論上のデータベースが故障し、エラーを発生させる可能性があります。データベースが失敗することは一般的ではないので、対応するエラーはクリティカルエラーとして返されます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">
</span>use juniper::{graphql_object, graphql_value, FieldError, GraphQLObject, GraphQLUnion, ScalarValue};

#[derive(GraphQLObject)]
pub struct Item {
    name: String,
    quantity: i32,
}

#[derive(GraphQLObject)]
pub struct ValidationErrorItem {
    name: Option&lt;String&gt;,
    quantity: Option&lt;String&gt;,
}

#[derive(GraphQLUnion)]
pub enum GraphQLResult {
    Ok(Item),
    Err(ValidationErrorItem),
}

pub enum ApiError {
    Database,
}

impl&lt;S: ScalarValue&gt; juniper::IntoFieldError&lt;S&gt; for ApiError {
    fn into_field_error(self) -&gt; FieldError&lt;S&gt; {
        match self {
            ApiError::Database =&gt; FieldError::new(
                &quot;Internal database error&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;DATABASE&quot;
                }),
            ),
        }
    }
}

pub struct Mutation;

#[graphql_object]
impl Mutation {
    fn addItem(&amp;self, name: String, quantity: i32) -&gt; Result&lt;GraphQLResult, ApiError&gt; {
        let mut error = ValidationErrorItem {
            name: None,
            quantity: None,
        };

        if !(10 &lt;= name.len() &amp;&amp; name.len() &lt;= 100) {
            error.name = Some(&quot;between 10 and 100&quot;.to_string());
        }

        if !(1 &lt;= quantity &amp;&amp; quantity &lt;= 10) {
            error.quantity = Some(&quot;between 1 and 10&quot;.to_string());
        }

        if error.name.is_none() &amp;&amp; error.quantity.is_none() {
            Ok(GraphQLResult::Ok(Item { name, quantity }))
        } else {
            Ok(GraphQLResult::Err(error))
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="追加資料"><a class="header" href="#追加資料">追加資料</a></h2>
<p><a href="https://shopify.dev/docs/admin-api/graphql/reference">Shopify API</a>も同様のアプローチを実装しています。彼らのAPIは、実世界のアプリケーションでこのアプローチを探求するための良い参考となります。</p>
<h1 id="比較"><a class="header" href="#比較">比較</a></h1>
<p>上で説明した最初のアプローチ、つまりすべてのエラーが <code>FieldResult</code> で定義されたクリティカルエラーである場合、実装はより簡単です。しかし、クライアントはどのようなエラーが発生するのかを知らないので、代わりにエラー文字列から何が起こったのかを推測しなければなりません。これは脆弱で、クライアントやサーバーが変化することによって、時間の経過とともに変化する可能性があります。したがって、クライアントとサーバー間の暗黙の契約を維持するために、クライアントとサーバー間の広範な統合テストが必要とされます。</p>
<p>GraphQLスキーマにクリティカルでないエラーをエンコードすることで、クライアントとサーバーの間の契約を明示的にします。これにより、クライアントはこれらのエラーを理解して正しく処理することができ、サーバーは変更がクライアントを破壊する可能性があることを知ることができます。しかし、このエラー情報をGraphQLスキーマにエンコードするためには、追加のコードとノンクリティカルエラーの先行定義が必要です。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="その他の型"><a class="header" href="#その他の型">その他の型</a></h1>
<p>GraphQLの型システムには、オブジェクトの他にいくつかの型が用意されています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="列挙型"><a class="header" href="#列挙型">列挙型</a></h1>
<p>GraphQLにおける列挙型は、可能な値の集合を表すためにグループ化された文字列定数です。単純なRustの列挙型は、カスタムのderive属性を使用することでGraphQLの列挙型に変換することができます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>#[derive(juniper::GraphQLEnum)]
enum Episode {
    NewHope,
    Empire,
    Jedi,
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Juniper はすべての enum 変数を大文字に変換するので、対応する文字列の値はそれぞれ <code>NEWHOPE</code>、<code>EMPIRE</code>、<code>JEDI</code> となります。もし、これを上書きしたい場合は、<code>graphql</code>属性を使用します。これは、<a href="types/objects/defining_objects.html">オブジェクトの定義</a>と同じように動作します。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>#[derive(juniper::GraphQLEnum)]
enum Episode {
    #[graphql(name=&quot;NEW_HOPE&quot;)]
    NewHope,
    Empire,
    Jedi,
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="ドキュメンテーションと非推奨"><a class="header" href="#ドキュメンテーションと非推奨">ドキュメンテーションと非推奨</a></h2>
<p>オブジェクトを定義するときと同じように、型そのものは名前を変えて文書化することができ、個々の列挙型の変種は名前を変えて文書化し、非推奨にすることができます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>#[derive(juniper::GraphQLEnum)]
#[graphql(name=&quot;Episode&quot;, description=&quot;An episode of Star Wars&quot;)]
enum StarWarsEpisode {
    #[graphql(deprecated=&quot;We don't really talk about this one&quot;)]
    ThePhantomMenace,

    #[graphql(name=&quot;NEW_HOPE&quot;)]
    NewHope,

    #[graphql(description=&quot;Arguably the best one in the trilogy&quot;)]
    Empire,
    Jedi,
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<table><thead><tr><th>Name of Attribute</th><th style="text-align: center">Container Support</th><th style="text-align: center">Field Support</th></tr></thead><tbody>
<tr><td>context</td><td style="text-align: center">✔</td><td style="text-align: center">?</td></tr>
<tr><td>deprecated</td><td style="text-align: center">✔</td><td style="text-align: center">✔</td></tr>
<tr><td>description</td><td style="text-align: center">✔</td><td style="text-align: center">✔</td></tr>
<tr><td>interfaces</td><td style="text-align: center">?</td><td style="text-align: center">✘</td></tr>
<tr><td>name</td><td style="text-align: center">✔</td><td style="text-align: center">✔</td></tr>
<tr><td>no-async</td><td style="text-align: center">✔</td><td style="text-align: center">?</td></tr>
<tr><td>scalar</td><td style="text-align: center">✘</td><td style="text-align: center">?</td></tr>
<tr><td>skip</td><td style="text-align: center">?</td><td style="text-align: center">✘</td></tr>
<tr><td>✔: supported</td><td style="text-align: center">✘: not supported</td><td style="text-align: center">?: not available</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="インターフェイス"><a class="header" href="#インターフェイス">インターフェイス</a></h1>
<p><a href="https://spec.graphql.org/June2018/#sec-Interfaces">GraphQLインターフェース</a>は、Java や C# などの一般的なオブジェクト指向言語で知られているインターフェースによく対応していますが、残念ながら Rust には完全に対応する概念がありません。<a href="https://spec.graphql.org/June2018/#sec-Interfaces">GraphQLインターフェース</a>に最も近いアナログはRust traitで、主な違いは、GraphQLでは<a href="https://spec.graphql.org/June2018/#sec-Interfaces">interface type</a>は抽象化と boxed 値(具象実装者にダウンキャスト可能)として機能しますが、Rustではtraitは抽象化のみでその boxed 値を表現するにはenumやtrait objectなどの別のタイプが必要_です、Rust traitでは型自体を表現しないので値を持てないのです。この違いは、Rustで<a href="https://spec.graphql.org/June2018/#sec-Interfaces">GraphQLインターフェース</a>を表現しようとしたときに、直感的でない、明らかでないコーナーケースをもたらしますが、一方で、どの型がインターフェースを支えるのか、そしてどのように解決するのかを完全に制御することができます。</p>
<p><a href="https://spec.graphql.org/June2018/#sec-Interfaces">GraphQLインターフェース</a>を実装するために、Juniperは <code>#[graphql_interface]</code> マクロを提供します。</p>
<h2 id="トレイト"><a class="header" href="#トレイト">トレイト</a></h2>
<p><a href="https://spec.graphql.org/June2018/#sec-Interfaces">GraphQLインターフェース</a>を定義するためには trait の定義が必須です。これは Rust における abstraction を記述する 自明な方法だからです。すべての<a href="https://spec.graphql.org/June2018/#sec-Interfaces">interface</a>フィールドは、traitメソッドによって計算されたものとして定義されます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>use juniper::graphql_interface;

#[graphql_interface]
trait Character {
    fn id(&amp;self) -&gt; &amp;str;
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>ただし、このような<a href="https://spec.graphql.org/June2018/#sec-Interfaces">interface</a>の値を返すためには、その実装者と、この特質の boxed 値を表すRust型を提供する必要があります。この型は，enum型と<a href="https://doc.rust-lang.org/reference/types/trait-object.html">trait object</a>の2種類があります．</p>
<h3 id="既定の列挙値"><a class="header" href="#既定の列挙値">既定の列挙値</a></h3>
<p>デフォルトでは、Juniper は定義された <a href="https://spec.graphql.org/June2018/#sec-Interfaces">GraphQL interface</a> の値を表す enum を生成し、素直に <code>{Interface}Value</code> という名前を付けます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>use juniper::{graphql_interface, GraphQLObject};

#[graphql_interface(for = [Human, Droid])] // すべてのインプリメンターの列挙が必須.
trait Character {
    fn id(&amp;self) -&gt; &amp;str;
}

#[derive(GraphQLObject)]
#[graphql(impl = CharacterValue)] // 列挙型の名前であり、traitの名前ではないことに注意してください.
struct Human {
    id: String,
}

#[derive(GraphQLObject)]
#[graphql(impl = CharacterValue)]
struct Droid {
    id: String,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>また、必要に応じて、列挙型の名前を明示的に指定することができます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>use juniper::{graphql_interface, GraphQLObject};

#[graphql_interface(enum = CharacterInterface, for = Human)] 
trait Character {
    fn id(&amp;self) -&gt; &amp;str;
}

#[derive(GraphQLObject)]
#[graphql(impl = CharacterInterface)]
struct Human {
    id: String,
    home_planet: String,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3 id="トレイトメソッドを無視する"><a class="header" href="#トレイトメソッドを無視する">トレイトメソッドを無視する</a></h3>
<p><a href="https://spec.graphql.org/June2018/#sec-Interfaces">GraphQL interface</a>のフィールドとして想定するため、一部のtraitメソッドを省略し、無視したい場合があります。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>use juniper::{graphql_interface, GraphQLObject};

#[graphql_interface(for = Human)]  
trait Character {
    fn id(&amp;self) -&gt; &amp;str;

    #[graphql(ignore)] // または #[graphql(skip)], お好みで。
    fn ignored(&amp;self) -&gt; u32 { 0 }
}

#[derive(GraphQLObject)]
#[graphql(impl = CharacterValue)]
struct Human {
    id: String,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3 id="フィールド引数インターフェースのカスタマイズ"><a class="header" href="#フィールド引数インターフェースのカスタマイズ">フィールド、引数、インターフェースのカスタマイズ</a></h3>
<p><a href="https://spec.graphql.org/June2018/#sec-Objects">GraphQLオブジェクト</a>と同様に、Juniperでは<a href="https://spec.graphql.org/June2018/#sec-Interfaces">interface</a>のフィールドとその引数を完全にカスタマイズすることができます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(deprecated)]
</span><span class="boring">extern crate juniper;
</span>use juniper::graphql_interface;

// GraphQLスキーマのインターフェイスの名前を変更します.
#[graphql_interface(name = &quot;MyCharacter&quot;)] 
// GraphQLスキーマでインターフェイスを記述します.
#[graphql_interface(description = &quot;My own character.&quot;)]
// 通常の Rust docs も GraphQL インターフェイスの記述としてサポートされていますが、 description 属性が指定されている場合は、そちらが優先されます.
/// このdocはGraphQLスキーマには存在しません. 
trait Character {
    // GraphQLスキーマのフィールド名を変更します.
    #[graphql(name = &quot;myId&quot;)]
    // GraphQL スキーマのフィールドを非推奨とします.
    // 通常の Rust #[deprecated] 属性も非推奨フィールドとしてサポートされているが、 deprecated 属性引数が指定されていれば、そちらが優先されます.
    #[graphql(deprecated = &quot;Do not use it.&quot;)]
    // GraphQL スキーマでフィールドを記述します.
    #[graphql(description = &quot;ID of my own character.&quot;)]
    // Rust の通常のドキュメントもフィールドの説明としてサポートされているが、 description`属性が指定されていれば、そちらが優先される。
    /// GraphQLスキーマにはこの記述はありません.
    fn id(
        &amp;self,
        // GraphQLスキーマでの引数の名前を変更します.
        #[graphql(name = &quot;myNum&quot;)]
        // GraphQLスキーマで引数を記述します.
        #[graphql(description = &quot;ID number of my own character.&quot;)]
        // 引数のデフォルト値を指定します.
        // 具体的な値は省略可能で、その場合は Default::default のものが使用されます.
        #[graphql(default = 5)]
        num: i32,
    ) -&gt; &amp;str;
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>すべての<a href="https://spec.graphql.org/June2018/#sec-Interfaces">GraphQL interface</a>フィールドと引数のリネームポリシーもサポートされています。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(deprecated)]
</span><span class="boring">extern crate juniper;
</span>use juniper::graphql_interface;

#[graphql_interface(rename_all = &quot;none&quot;)] // リネームを無効にします.
trait Character {
    // スキーマで my_id と my_num として公開されるようになりました.
    fn my_id(&amp;self, my_num: i32) -&gt; &amp;str;
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3 id="カスタムコンテキスト"><a class="header" href="#カスタムコンテキスト">カスタムコンテキスト</a></h3>
<p><a href="https://spec.graphql.org/June2018/#sec-Interfaces">GraphQL interface</a> フィールドを解決するために、trait メソッドで <a href="https://docs.rs/juniper/0.14.2/juniper/trait.Context.html"><code>Context</code></a> が必要な場合は、引数として指定します。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use std::collections::HashMap;
</span>use juniper::{graphql_interface, GraphQLObject};

struct Database {
    humans: HashMap&lt;String, Human&gt;,
}
impl juniper::Context for Database {}

#[graphql_interface(for = Human)] // 見て、ママ、コンテキストの型が推論されてる! ＼(^o^)／
trait Character {
    // フィールドの引数が context または ctx という名前であれば、自動的にコンテキスト引数として扱われます.
    fn id(&amp;self, context: &amp;Database) -&gt; Option&lt;&amp;str&gt;;

    // そうでない場合は、明示的にコンテキスト引数としてマークすることができます.
    fn name(&amp;self, #[graphql(context)] db: &amp;Database) -&gt; Option&lt;&amp;str&gt;;
}

#[derive(GraphQLObject)]
#[graphql(impl = CharacterValue, Context = Database)]
struct Human {
    id: String,
    name: String,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3 id="エクゼキュータと明示的なジェネリックスカラを使う"><a class="header" href="#エクゼキュータと明示的なジェネリックスカラを使う">エクゼキュータと明示的なジェネリックスカラを使う</a></h3>
<p><a href="https://spec.graphql.org/June2018/#sec-Interfaces">GraphQL interface</a> フィールドを解決するために trait メソッド内で <a href="https://docs.rs/juniper/latest/juniper/struct.Executor.html"><code>Executor</code></a> が必要な場合、それを引数として指定します。</p>
<p>この場合、<a href="https://docs.rs/juniper/latest/juniper/struct.Executor.html"><code>Executor</code></a> がそうであるように、明示的に <a href="https://docs.rs/juniper/latest/juniper/trait.ScalarValue.html"><code>ScalarValue</code></a> をパラメトリックにする必要があります。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>use juniper::{graphql_interface, graphql_object, Executor, LookAheadMethods as _, ScalarValue};

#[graphql_interface(for = Human, Scalar = S)] // 既存の型パラメータとして ScalarValue を指定している.
trait Character&lt;S: ScalarValue&gt; {             
    // フィールドの引数が executor という名前であれば、自動的にエグゼキュータ引数として扱われます.
    fn id&lt;'a&gt;(&amp;self, executor: &amp;'a Executor&lt;'_, '_, (), S&gt;) -&gt; &amp;'a str;

    // そうでない場合は、エグゼキュータ引数として明示的にマークすることができます.
    fn name&lt;'b&gt;(
        &amp;'b self,
        #[graphql(executor)] another: &amp;Executor&lt;'_, '_, (), S&gt;,
    ) -&gt; &amp;'b str;
    
    fn home_planet(&amp;self) -&gt; &amp;str;
}

struct Human {
    id: String,
    name: String,
    home_planet: String,
}
#[graphql_object(scalar = S: ScalarValue, impl = CharacterValue&lt;S&gt;)]
impl Human {
    async fn id&lt;'a, S&gt;(&amp;self, executor: &amp;'a Executor&lt;'_, '_, (), S&gt;) -&gt; &amp;'a str 
    where
        S: ScalarValue,
    {
        executor.look_ahead().field_name()
    }

    async fn name&lt;'b, S&gt;(&amp;'b self, #[graphql(executor)] _: &amp;Executor&lt;'_, '_, (), S&gt;) -&gt; &amp;'b str {
        &amp;self.name
    }
    
    fn home_planet&lt;'c, S&gt;(&amp;'c self, #[graphql(executor)] _: &amp;Executor&lt;'_, '_, (), S&gt;) -&gt; &amp;'c str {
        // トレイトメソッドにはエクゼキュータが存在しない場合があります.
        &amp;self.home_planet
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="scalarvalueの考察"><a class="header" href="#scalarvalueの考察">ScalarValueの考察</a></h2>
<p>デフォルトでは <code>#[graphql_interface]</code> マクロは <a href="https://docs.rs/juniper/latest/juniper/trait.ScalarValue.html"><code>ScalarValue</code></a> 型に対するジェネリックコードを生成します。これは、<a href="https://spec.graphql.org/June2018/#sec-Interfaces">GraphQL interface</a> の実装者のうち少なくとも1人が、その実装において具象的な <a href="https://docs.rs/juniper/latest/juniper/trait.ScalarValue.html"><code>ScalarValue</code></a> 型に制限されている場合に問題を引き起こす可能性があります。このような問題を解決するためには、具象 <a href="https://docs.rs/juniper/latest/juniper/trait.ScalarValue.html"><code>ScalarValue</code></a> 型を指定する必要があります。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>use juniper::{graphql_interface, DefaultScalarValue, GraphQLObject};

#[graphql_interface(for = [Human, Droid])]
#[graphql_interface(scalar = DefaultScalarValue)] // この行を削除すると、コンパイルに失敗します.
trait Character {
    fn id(&amp;self) -&gt; &amp;str;
}

#[derive(GraphQLObject)]
#[graphql(impl = CharacterValue, Scalar = DefaultScalarValue)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(GraphQLObject)]
#[graphql(impl = CharacterValue, Scalar = DefaultScalarValue)]
struct Droid {
    id: String,
    primary_function: String,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力オブジェクト"><a class="header" href="#入力オブジェクト">入力オブジェクト</a></h1>
<p>入力オブジェクトは、GraphQLフィールドの引数として使用することができる複雑なデータ構造です。Juniperでは、単純なオブジェクトやenumと同様に、カスタムのderive属性を使用して入力オブジェクトを定義できます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">extern crate juniper;
</span>#[derive(juniper::GraphQLInputObject)]
struct Coordinate {
    latitude: f64,
    longitude: f64
}

struct Root;
<span class="boring">#[derive(juniper::GraphQLObject)] struct User { name: String }
</span>
#[juniper::graphql_object]
impl Root {
    fn users_at_location(coordinate: Coordinate, radius: f64) -&gt; Vec&lt;User&gt; {
        // 座標をデータベースに送信する.
        // ...
<span class="boring">unimplemented!()
</span>    }
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="ドキュメンテーションとリネーム"><a class="header" href="#ドキュメンテーションとリネーム">ドキュメンテーションとリネーム</a></h2>
<p>他のderivesと同じように、型とフィールドの両方の名前を変更したり、ドキュメントを追加したりすることが可能です。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">extern crate juniper;
</span>#[derive(juniper::GraphQLInputObject)]
#[graphql(name=&quot;Coordinate&quot;, description=&quot;A position on the globe&quot;)]
struct WorldCoordinate {
    #[graphql(name=&quot;lat&quot;, description=&quot;The latitude&quot;)]
    latitude: f64,

    #[graphql(name=&quot;long&quot;, description=&quot;The longitude&quot;)]
    longitude: f64
}

struct Root;
<span class="boring">#[derive(juniper::GraphQLObject)] struct User { name: String }
</span>
#[juniper::graphql_object]
impl Root {
    fn users_at_location(coordinate: WorldCoordinate, radius: f64) -&gt; Vec&lt;User&gt; {
        // 座標をデータベースに送信する.
        // ...
<span class="boring">unimplemented!()
</span>    }
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="スカラー"><a class="header" href="#スカラー">スカラー</a></h1>
<p>スカラーは、GraphQLクエリの先頭にあるプリミティブな型であり、数値、文字列、ブーリアンです。他のプリミティブ値に対するカスタムスカラーを作成することもできますが、この場合、構築するAPIを利用するためのクライアントライブラリとの調整が必要になることがよくあります。</p>
<p>ワイヤーを介した値は最終的にJSONに変換されるため、使用できるデータ型も限定されます。</p>
<p>カスタムスカラーを定義するには、2つの方法があります。</p>
<ul>
<li>プリミティブ型をラップするだけの単純なスカラーであれば、newtypeパターンとカスタムderiveを使用することができる。</li>
<li>より高度な検証を行う場合は、 <code>graphql_scalar</code> 手続き型マクロを使用することができます。</li>
</ul>
<h2 id="組み込みスカラー"><a class="header" href="#組み込みスカラー">組み込みスカラー</a></h2>
<p>ジュニパーは、以下の組み込みをサポートしています。</p>
<ul>
<li><code>i32</code> を <code>Int</code> とします。</li>
<li><code>f64</code> を <code>Float</code> とします。</li>
<li>文字列 <code>String</code> と <code>&amp;str</code> は <code>String</code> とします。</li>
<li>ブール演算子として <code>bool</code> を使用します。</li>
<li><code>juniper::ID</code> を <code>ID</code> とします。この型は <a href="http://facebook.github.io/graphql/#sec-ID">in the spec</a> は、文字列としてシリアライズされますが、文字列と整数の両方からパースできるタイプです。</li>
</ul>
<p>GraphQL 仕様では、<a href="https://spec.graphql.org/June2018/#sec-Int"><code>i64</code>/<code>u64</code> に対する組み込みのスカラーはデフォルトで定義されていない</a> ので、<code>i64</code>/<code>u64</code> に対する組み込みのサポートはないことに注意してください。スキーマで <a href="types/scalars.html#custom-scalars">カスタム GraphQL スカラー</a> を利用して、これらをサポートすることができます。</p>
<h2 id="サードパーティーの型"><a class="header" href="#サードパーティーの型">サードパーティーの型</a></h2>
<p>Juniperは、一般的なサードパーティークレートから、さらにいくつかのタイプを組み込みでサポートしています。これらは、デフォルトでオンになっている機能によって有効化されます。</p>
<ul>
<li>uuid::Uuid</li>
<li>chrono::DateTime</li>
<li>time::{Date, OffsetDateTime, PrimitiveDateTime, Time, UtcOffset}</li>
<li>url::Url</li>
<li>bson::oid::ObjectId</li>
</ul>
<h2 id="newtype-パターン"><a class="header" href="#newtype-パターン">newtype パターン</a></h2>
<p>既存の型をラップしただけのカスタムスカラーが必要な場合がよくあります。</p>
<p>これは、serde が <code>#[serde(transparent)]</code> でこのパターンをサポートしているのと同様に、 newtype パターンとカスタム derive で実現することができます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>#[derive(juniper::GraphQLScalarValue)]
pub struct UserId(i32);

#[derive(juniper::GraphQLObject)]
struct User {
    id: UserId,
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>以上で、スキーマに <code>UserId</code> を使用できるようになりました。</p>
<p>また、このマクロを使うことで、よりカスタマイズが可能になります。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>/// doc commentを使用して説明を指定することができます.
#[derive(juniper::GraphQLScalarValue)]
#[graphql(
    transparent,
    // GraphQLの型名に上書きします.
    name = &quot;MyUserId&quot;,
    // カスタムの説明を指定します.
    // 属性に記述すると、docコメントが上書きされます.
    description = &quot;My user id description&quot;,
)]
pub struct UserId(i32);

<span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="カスタムスカラー"><a class="header" href="#カスタムスカラー">カスタムスカラー</a></h2>
<p>カスタムパースやバリデーションが必要な、より複雑な状況では、 <code>graphql_scalar</code> 手続き型マクロを使用することができます。</p>
<p>通常、カスタムスカラーは文字列として表現されます。</p>
<p>以下の例では、カスタムの <code>Date</code> 型のスカラーを実装しています。</p>
<p>注意: juniper は <code>chrono::DateTime</code> 型を <code>chrono</code> 機能で既に組み込んでおり、これはデフォルトで有効になっているので、この目的に使用することができます。</p>
<p>以下の例は、説明のために使用しています。</p>
<p><strong>注意</strong>: この例では、 <code>Date</code> 型が <code>std::fmt::Display</code> と <code>std::str::FromStr</code> を実装していると仮定しています。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">mod date {
</span><span class="boring">   pub struct Date;
</span><span class="boring">   impl std::str::FromStr for Date {
</span><span class="boring">       type Err = String; fn from_str(_value: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; { unimplemented!() }
</span><span class="boring">   }
</span><span class="boring">   // そして、日付を文字列として表現する方法を定義しています.
</span><span class="boring">   impl std::fmt::Display for Date {
</span><span class="boring">       fn fmt(&amp;self, _f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
</span><span class="boring">           unimplemented!()
</span><span class="boring">       }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>use juniper::{Value, ParseScalarResult, ParseScalarValue};
use date::Date;

#[juniper::graphql_scalar(description = &quot;Date&quot;)]
impl&lt;S&gt; GraphQLScalar for Date
where
    S: ScalarValue
{
    // カスタムスカラーをプリミティブ型に変換する方法を定義します.
    fn resolve(&amp;self) -&gt; Value {
        Value::scalar(self.to_string())
    }

    // プリミティブ型のパース方法を定義し、独自のスカラーを作成します.
    // 注意: エラーの種類は IntoFieldError&lt;S&gt; を実装する必要があります。
    fn from_input_value(v: &amp;InputValue) -&gt; Result&lt;Date, String&gt; {
        v.as_string_value()
            .ok_or_else(|| format!(&quot;Expected `String`, found: {}&quot;, v))
            .and_then(|s| s.parse().map_err(|e| format!(&quot;Failed to parse `Date`: {}&quot;, e)))
    }

    // 文字列値のパース方法を定義します.
    fn from_str&lt;'a&gt;(value: ScalarToken&lt;'a&gt;) -&gt; ParseScalarResult&lt;'a, S&gt; {
        &lt;String as ParseScalarValue&lt;S&gt;&gt;::from_str(value)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ユニオン"><a class="header" href="#ユニオン">ユニオン</a></h1>
<p>サーバーから見ると、<a href="https://spec.graphql.org/June2018/#sec-Unions">ユニオン</a> は <a href="https://spec.graphql.org/June2018/#sec-Interfaces">インターフェース</a> にやや似ています。主な違いは、それ自体にフィールドが含まれないことです。</p>
<p>Rustで<a href="https://spec.graphql.org/June2018/#sec-Unions">ユニオン</a>を表現する最も明白でわかりやすい方法はenumです。しかし、trait や通常の struct でも表現することができます。そのため、Juniperでは<a href="https://spec.graphql.org/June2018/#sec-Unions">ユニオン</a>を実装するために、以下のようなものを用意しています。</p>
<ul>
<li>enumと構造体に対して <code>#[derive(GraphQLUnion)]</code> というマクロを用意しています。</li>
<li>trait には <code>#[graphql_union]</code> マクロを提供します。</li>
</ul>
<h2 id="列挙体"><a class="header" href="#列挙体">列挙体</a></h2>
<p>ほとんどの場合、<a href="https://spec.graphql.org/June2018/#sec-Unions">ユニオン</a>を表現するために、些細でわかりやすいRust enumが必要なだけです。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">extern crate derive_more;
</span>use derive_more::From;
use juniper::{GraphQLObject, GraphQLUnion};

#[derive(GraphQLObject)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(GraphQLObject)]
struct Droid {
    id: String,
    primary_function: String,
}

#[derive(From, GraphQLUnion)]
enum Character {
    Human(Human),
    Droid(Droid),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3 id="列挙体のバリアントを無視する"><a class="header" href="#列挙体のバリアントを無視する">列挙体のバリアントを無視する</a></h3>
<p>稀な状況として、GraphQLスキーマでenumバリアントを公開することを省略したい場合があります。</p>
<p>例として、リゾルバで型レベルの面白いことをするために、ある型パラメータ <code>T</code> をバインドする必要がある状況を考えてみましょう。これを実現するためには、 <code>PhantomData&lt;T&gt;</code> が必要だが、GraphQL スキーマで公開する必要はありません。</p>
<blockquote>
<p><strong>WARNING</strong>:
さもなければ、GraphQL クエリの解決は実行時にパニックになります。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">extern crate derive_more;
</span><span class="boring">use std::marker::PhantomData;
</span>use derive_more::From;
use juniper::{GraphQLObject, GraphQLUnion};

#[derive(GraphQLObject)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(GraphQLObject)]
struct Droid {
    id: String,
    primary_function: String,
}

#[derive(From, GraphQLUnion)]
enum Character&lt;S&gt; {
    Human(Human),
    Droid(Droid),
    #[from(ignore)]
    #[graphql(ignore)]  // または #[graphql(skip)]、お好みで.
    _State(PhantomData&lt;S&gt;),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3 id="外部リゾルバ機能"><a class="header" href="#外部リゾルバ機能">外部リゾルバ機能</a></h3>
<p><a href="https://spec.graphql.org/June2018/#sec-Unions">ユニオン</a> のバリアントを解決するために何らかのカスタムロジックが必要な場合、それを行うための外部関数を指定することができます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate juniper;
</span>use juniper::{GraphQLObject, GraphQLUnion};

#[derive(GraphQLObject)]
#[graphql(Context = CustomContext)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(GraphQLObject)]
#[graphql(Context = CustomContext)]
struct Droid {
    id: String,
    primary_function: String,
}

pub struct CustomContext {
    droid: Droid,
}
impl juniper::Context for CustomContext {}

#[derive(GraphQLUnion)]
#[graphql(Context = CustomContext)]
enum Character {
    Human(Human),
    #[graphql(with = Character::droid_from_context)]
    Droid(Droid),
}

impl Character {
    // 注意: 関数のシグネチャは &amp;self と &amp;Context を含み、 Option&lt;&amp;VariantType&gt; を返さなければなりません。
    fn droid_from_context&lt;'c&gt;(&amp;self, ctx: &amp;'c CustomContext) -&gt; Option&lt;&amp;'c Droid&gt; {
        Some(&amp;ctx.droid)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>外部リゾルバ関数を使用すると、最初の列挙型の定義にRust型がない場合、新しい<a href="https://spec.graphql.org/June2018/#sec-Unions">ユニオン</a>バリアントを宣言することもできます。derive構文 <code>#[graphql(on VariantType = resolver_fn)]</code> は <a href="https://spec.graphql.org/June2018/#example-f8163">ユニオンバリアントをディスパッチするためのGraphQL構文</a> に従っています。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate juniper;
</span>use juniper::{GraphQLObject, GraphQLUnion};

#[derive(GraphQLObject)]
#[graphql(Context = CustomContext)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(GraphQLObject)]
#[graphql(Context = CustomContext)]
struct Droid {
    id: String,
    primary_function: String,
}

#[derive(GraphQLObject)]
#[graphql(Context = CustomContext)]
struct Ewok {
    id: String,
    is_funny: bool,
}

pub struct CustomContext {
    ewok: Ewok,
}
impl juniper::Context for CustomContext {}

#[derive(GraphQLUnion)]
#[graphql(Context = CustomContext)]
#[graphql(on Ewok = Character::ewok_from_context)]
enum Character {
    Human(Human),
    Droid(Droid),
    #[graphql(ignore)]  // または #[graphql(skip)]、お好みで.
    Ewok,
}

impl Character {
    fn ewok_from_context&lt;'c&gt;(&amp;self, ctx: &amp;'c CustomContext) -&gt; Option&lt;&amp;'c Ewok&gt; {
        if let Self::Ewok = self {
            Some(&amp;ctx.ewok)
        } else {
            None
        }       
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="構造体"><a class="header" href="#構造体">構造体</a></h2>
<p>Rust構造体を<a href="https://spec.graphql.org/June2018/#sec-Unions">ユニオン</a>として使用することは、enumの使用と非常に似ていますが、外部のリゾルバ関数を指定することが<a href="https://spec.graphql.org/June2018/#sec-Unions">ユニオン</a>のバリアントを宣言する唯一の方法というニュアンスがあります。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use std::collections::HashMap;
</span>use juniper::{GraphQLObject, GraphQLUnion};

#[derive(GraphQLObject)]
#[graphql(Context = Database)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(GraphQLObject)]
#[graphql(Context = Database)]
struct Droid {
    id: String,
    primary_function: String,
}

struct Database {
    humans: HashMap&lt;String, Human&gt;,
    droids: HashMap&lt;String, Droid&gt;,
}
impl juniper::Context for Database {}

#[derive(GraphQLUnion)]
#[graphql(
    Context = Database,
    on Human = Character::get_human,
    on Droid = Character::get_droid,
)]
struct Character {
    id: String,
}

impl Character {
    fn get_human&lt;'db&gt;(&amp;self, ctx: &amp;'db Database) -&gt; Option&lt;&amp;'db Human&gt;{
        ctx.humans.get(&amp;self.id)
    }

    fn get_droid&lt;'db&gt;(&amp;self, ctx: &amp;'db Database) -&gt; Option&lt;&amp;'db Droid&gt;{
        ctx.droids.get(&amp;self.id)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Rust の trait 定義を <a href="https://spec.graphql.org/June2018/#sec-Unions">ユニオン</a> として使用するには、 <code>#[graphql_union]</code> マクロを使用する必要があります。<a href="https://doc.rust-lang.org/stable/reference/procedural-macros.html#derive-macros">Rustはtraitに対するderiveマクロを許可していません</a>ので、traitに対して <code>#[derive(GraphQLUnion)]</code> を使用してもうまくいきません。</p>
<blockquote>
<p><strong>NOTICE</strong>:<br />
なぜならスキーマリゾルバはその背後にある<a href="https://spec.graphql.org/June2018/#sec-Unions">ユニオン</a>を指定するために<a href="https://doc.rust-lang.org/stable/reference/types/trait-object.html">トレイトオブジェクト</a> を返さなければならないからです。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>use juniper::{graphql_union, GraphQLObject};

#[derive(GraphQLObject)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(GraphQLObject)]
struct Droid {
    id: String,
    primary_function: String,
}

#[graphql_union]
trait Character {
    // 注意: メソッドのシグネチャは &amp;self を含み、 Option&lt;&amp;VariantType&gt; を返さなければなりません.
    fn as_human(&amp;self) -&gt; Option&lt;&amp;Human&gt; { None }
    fn as_droid(&amp;self) -&gt; Option&lt;&amp;Droid&gt; { None }
}

impl Character for Human {
    fn as_human(&amp;self) -&gt; Option&lt;&amp;Human&gt; { Some(&amp;self) }
}

impl Character for Droid {
    fn as_droid(&amp;self) -&gt; Option&lt;&amp;Droid&gt; { Some(&amp;self) }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3 id="カスタムコンテキスト-1"><a class="header" href="#カスタムコンテキスト-1">カスタムコンテキスト</a></h3>
<p><a href="https://spec.graphql.org/June2018/#sec-Unions">ユニオン</a> のバリアントを解決するために trait メソッドで <a href="https://docs.rs/juniper/0.14.2/juniper/trait.Context.html"><code>Context</code></a> が必要な場合、それを引数として指定します。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">extern crate juniper;
</span><span class="boring">use std::collections::HashMap;
</span>use juniper::{graphql_union, GraphQLObject};

#[derive(GraphQLObject)]
#[graphql(Context = Database)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(GraphQLObject)]
#[graphql(Context = Database)]
struct Droid {
    id: String,
    primary_function: String,
}

struct Database {
    humans: HashMap&lt;String, Human&gt;,
    droids: HashMap&lt;String, Droid&gt;,
}
impl juniper::Context for Database {}

#[graphql_union(context = Database)]
trait Character {
    // 注意: メソッドのシグネチャは、オプションで &amp;Context を含むことができます.
    fn as_human&lt;'db&gt;(&amp;self, ctx: &amp;'db Database) -&gt; Option&lt;&amp;'db Human&gt; { None }
    fn as_droid&lt;'db&gt;(&amp;self, ctx: &amp;'db Database) -&gt; Option&lt;&amp;'db Droid&gt; { None }
}

impl Character for Human {
    fn as_human&lt;'db&gt;(&amp;self, ctx: &amp;'db Database) -&gt; Option&lt;&amp;'db Human&gt; {
        ctx.humans.get(&amp;self.id)
    }
}

impl Character for Droid {
    fn as_droid&lt;'db&gt;(&amp;self, ctx: &amp;'db Database) -&gt; Option&lt;&amp;'db Droid&gt; {
        ctx.droids.get(&amp;self.id)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3 id="トレイトメソッドを無視する-1"><a class="header" href="#トレイトメソッドを無視する-1">トレイトメソッドを無視する</a></h3>
<p>enum と同様に、いくつかの trait メソッドを省略して <a href="https://spec.graphql.org/June2018/#sec-Unions">ユニオン</a> のバリアントとして想定し、それらを無視したい場合があります。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>use juniper::{graphql_union, GraphQLObject};

#[derive(GraphQLObject)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(GraphQLObject)]
struct Droid {
    id: String,
    primary_function: String,
}

#[graphql_union]
trait Character {
    fn as_human(&amp;self) -&gt; Option&lt;&amp;Human&gt; { None }
    fn as_droid(&amp;self) -&gt; Option&lt;&amp;Droid&gt; { None }
    #[graphql(ignore)]  // または #[graphql(skip)]、お好みで.
    fn id(&amp;self) -&gt; &amp;str;
}

impl Character for Human {
    fn as_human(&amp;self) -&gt; Option&lt;&amp;Human&gt; { Some(&amp;self) }
    fn id(&amp;self) -&gt; &amp;str { self.id.as_str() }
}

impl Character for Droid {
    fn as_droid(&amp;self) -&gt; Option&lt;&amp;Droid&gt; { Some(&amp;self) }
    fn id(&amp;self) -&gt; &amp;str { self.id.as_str() }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3 id="外部リゾルバ機能-1"><a class="header" href="#外部リゾルバ機能-1">外部リゾルバ機能</a></h3>
<p>enumやstructと同様に、<a href="https://spec.graphql.org/June2018/#sec-Unions">ユニオン</a> variant resolverとしてtraitメソッドを使用することは必須ではありません。その代わり、カスタム関数を指定することができます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use std::collections::HashMap;
</span>use juniper::{graphql_union, GraphQLObject};

#[derive(GraphQLObject)]
#[graphql(Context = Database)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(GraphQLObject)]
#[graphql(Context = Database)]
struct Droid {
    id: String,
    primary_function: String,
}

struct Database {
    humans: HashMap&lt;String, Human&gt;,
    droids: HashMap&lt;String, Droid&gt;,
}
impl juniper::Context for Database {}

#[graphql_union(context = Database)]
#[graphql_union(
    on Human = DynCharacter::get_human,
    on Droid = get_droid,
)]
trait Character {
    #[graphql(ignore)]  // または #[graphql(skip)]、お好みで.
    fn id(&amp;self) -&gt; &amp;str;
}

impl Character for Human {
    fn id(&amp;self) -&gt; &amp;str { self.id.as_str() }
}

impl Character for Droid {
    fn id(&amp;self) -&gt; &amp;str { self.id.as_str() }
}

// trait オブジェクトは常に `Send` と `Sync` です。
type DynCharacter&lt;'a&gt; = dyn Character + Send + Sync + 'a;

impl&lt;'a&gt; DynCharacter&lt;'a&gt; {
    fn get_human&lt;'db&gt;(&amp;self, ctx: &amp;'db Database) -&gt; Option&lt;&amp;'db Human&gt; {
        ctx.humans.get(self.id())
    }
}

// 外部リゾルバ関数は、ある型のメソッドである必要はありません.
// あくまでも要件に合わせたファンクションシグネチャーの問題です.
fn get_droid&lt;'db&gt;(ch: &amp;DynCharacter&lt;'_&gt;, ctx: &amp;'db Database) -&gt; Option&lt;&amp;'db Droid&gt; {
    ctx.droids.get(ch.id())
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="スカラ値の考察"><a class="header" href="#スカラ値の考察">スカラ値の考察</a></h2>
<p>デフォルトでは <code>#[derive(GraphQLUnion)]</code> と <code>#[graphql_union]</code> マクロは <a href="https://docs.rs/juniper/latest/juniper/trait.ScalarValue.html"><code>ScalarValue</code></a> 型に対してジェネリックなコードを生成します。これは、<a href="https://spec.graphql.org/June2018/#sec-Unions">ユニオン</a> の少なくとも1つのバリアントが、その実装において具象的な <a href="https://docs.rs/juniper/latest/juniper/trait.ScalarValue.html"><code>ScalarValue</code></a> 型に制限されている場合に問題を引き起こす可能性があります。このような問題を解決するには、具体的な <a href="https://docs.rs/juniper/latest/juniper/trait.ScalarValue.html"><code>ScalarValue</code></a> 型を指定する必要があります。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate juniper;
</span>use juniper::{DefaultScalarValue, GraphQLObject, GraphQLUnion};

#[derive(GraphQLObject)]
#[graphql(Scalar = DefaultScalarValue)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(GraphQLObject)]
struct Droid {
    id: String,
    primary_function: String,
}

#[derive(GraphQLUnion)]
#[graphql(Scalar = DefaultScalarValue)]  // この行を削除すると、コンパイルに失敗します.
enum Character {
    Human(Human),
    Droid(Droid),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="スキーマとミューテーション"><a class="header" href="#スキーマとミューテーション">スキーマとミューテーション</a></h1>
<p>Juniperは、GraphQLのスキーマを定義する際、<a href="https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/">コードファースト方式</a> に従っています。<a href="https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/">スキーマファースト方式</a>を採用したい場合は、スキーマファイルからコードを生成する<a href="https://github.com/davidpdrsn/juniper-from-schema">juniper-from-schema</a>を検討してみてください。</p>
<p>スキーマは、クエリオブジェクト、ミューテーションオブジェクト、サブスクリプションオブジェクトの3つのタイプから構成されています。
この3つはそれぞれ、スキーマのルート・クエリー・フィールド、ミューテーション、サブスクリプションを定義します。</p>
<p>サブスクリプションの使い方は、ミューテーションやクエリオブジェクトと少し異なるので、それらについて説明する特定の[セクション][セクション]が用意されています。</p>
<p>クエリーとミューテーションの両オブジェクトは、通常のGraphQLオブジェクトで、Juniperの他のオブジェクトと同様に定義されます。ただし、スキーマは読み取り専用にすることができ、サブスクリプションを必要としないため、MutationオブジェクトとSubscriptionオブジェクトはオプションとなります。ミューテーション／サブスクリプション機能が不要な場合は、<a href="https://docs.rs/juniper/0.14.2/juniper/struct.EmptyMutation.html">EmptyMutation</a>／<a href="https://docs.rs/juniper/0.14.2/juniper/struct.EmptySubscription.html">EmptySubscription</a>の利用を検討してください。</p>
<p>Juniper では、<code>RootNode</code> 型はスキーマを表します。スキーマが最初に作成されると、Juniperはオブジェクトグラフ全体をトラバースして、見つけられたすべてのタイプを登録します。つまり、どこかでGraphQLオブジェクトを定義しても、それを参照することがなければ、スキーマで公開されることはないのです。</p>
<h2 id="クエリールート"><a class="header" href="#クエリールート">クエリールート</a></h2>
<p>クエリルートは単なるGraphQLオブジェクトです。Juniper の他の GraphQL オブジェクトと同じように、 <code>graphql_object</code> 手続き型マクロを使用して定義します。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::{graphql_object, FieldResult, GraphQLObject};
</span><span class="boring">#[derive(GraphQLObject)] struct User { name: String }
</span>struct Root;

#[graphql_object]
impl Root {
    fn userWithUsername(username: String) -&gt; FieldResult&lt;Option&lt;User&gt;&gt; {
        // データベースでユーザーを検索する...
<span class="boring">      unimplemented!()
</span>    }
}
<span class="boring">
</span><span class="boring">fn main() { }
</span></code></pre></pre>
<h2 id="ミューテーション"><a class="header" href="#ミューテーション">ミューテーション</a></h2>
<p>ミューテーションは単なるGraphQLオブジェクトです。各変異は、データベースを更新するような変異の副作用を実行する単一のフィールドです。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::{graphql_object, FieldResult, GraphQLObject};
</span><span class="boring">#[derive(GraphQLObject)] struct User { name: String }
</span>struct Mutations;

#[graphql_object]
impl Mutations {
    fn signUpUser(name: String, email: String) -&gt; FieldResult&lt;User&gt; {
        // 入力を検証し、ユーザーをデータベースに保存する...
<span class="boring">      unimplemented!()
</span>    }
}
<span class="boring">
</span><span class="boring">fn main() { }
</span></code></pre></pre>
<h1 id="rust-スキーマを-graphql-schema-language-に変換する"><a class="header" href="#rust-スキーマを-graphql-schema-language-に変換する">Rust スキーマを <a href="https://graphql.org/learn/schema/#type-language">GraphQL Schema Language</a> に変換する</a></h1>
<p>GraphQLエコシステムの多くのツールは、スキーマを<a href="https://graphql.org/learn/schema/#type-language">GraphQL Schema Language</a>で定義することを要求しています。Rust で定義したスキーマを <a href="https://graphql.org/learn/schema/#type-language">GraphQL Schema Language</a> で表現したものを <code>schema-language</code> 機能で生成できます（デフォルトでオンになっています）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>use juniper::{
    graphql_object, EmptyMutation, EmptySubscription, FieldResult, RootNode,
};

struct Query;

#[graphql_object]
impl Query {
    fn hello(&amp;self) -&gt; FieldResult&lt;&amp;str&gt; {
        Ok(&quot;hello world&quot;)
    }
}

fn main() {
    // Rustでスキーマを定義する.
    let schema = RootNode::new(
        Query,
        EmptyMutation::&lt;()&gt;::new(),
        EmptySubscription::&lt;()&gt;::new(),
    );

    // Rust スキーマを GraphQL Schema Language に変換します.
    let result = schema.as_schema_language();

    let expected = &quot;\
type Query {
  hello: String!
}

schema {
  query: Query
}
&quot;;
    assert_eq!(result, expected);
}
</code></pre></pre>
<p>依存関係を減らしコンパイル時間を短縮するために、この機能が必要ない場合は<code>schema-language</code>機能をオフにすることができることに注意してください。</p>
<!-- TODO: EmptySubscriptionがドキュメントで利用可能になったときにこのURLを修正する. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="サーバーを追加する"><a class="header" href="#サーバーを追加する">サーバーを追加する</a></h1>
<p>Juniperを好みのHTTPサーバーで利用できるようにするため、HTTPサーバーは<strong>内蔵されていません</strong>。</p>
<p>実際にサーバーを立ち上げるには、複数の公式およびサードパーティの統合クレートがあります。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="juniperによる連携"><a class="header" href="#juniperによる連携">Juniperによる連携</a></h1>
<p>Juniperは、いくつかの一般的なRustサーバーライブラリに公式の統合クレートを提供しています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="warp"><a class="header" href="#warp">Warp</a></h1>
<p><a href="https://crates.io/crates/warp">Warp</a>は、超簡単でコンポーザブルな、ワープスピードのためのウェブサーバフレームワークです。
warpの基本的な構成要素はFilterです：それらは組み合わせたり、構成することでリクエストに対する豊富な要求を表現することができます。Warpは<a href="https://hyper.rs/">Hyper</a>をベースに構築されており、Rustの安定したチャンネルで動作します。</p>
<p>JuniperのWarp統合は、<a href="https://github.com/graphql-rust/juniper/tree/master/juniper_warp"><code>juniper_warp</code></a>クレートに含まれています。</p>
<pre><code class="language-toml">[dependencies]
juniper = &quot;0.15.7&quot;
juniper_warp = &quot;0.7.0&quot;
</code></pre>
<p>ソースには、基本的な GraphQL と <a href="https://github.com/graphql/graphiql">GraphiQL</a> ハンドラをセットアップする <a href="https://github.com/graphql-rust/juniper/blob/master/juniper_warp/examples/warp_server.rs">example</a> が含まれています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rocket"><a class="header" href="#rocket">Rocket</a></h1>
<p><a href="https://rocket.rs/">Rocket</a> は、RustのためのWebフレームワークで、柔軟性や型安全性を犠牲にすることなく、高速なWebアプリケーションを簡単に書くことができるようにするものです。すべて最小限のコードで。RocketはRustの安定版チャンネルでは動作せず、代わりにナイトリーチャンネルが必要です。</p>
<p>JuniperのRocket統合は、<a href="https://github.com/graphql-rust/juniper/tree/master/juniper_rocket"><code>juniper_rocket</code></a>クレートに含まれています。</p>
<pre><code class="language-toml">[dependencies]
juniper = &quot;0.15.7&quot;
juniper_rocket = &quot;0.8.0&quot;
</code></pre>
<p>ソースには、基本的な GraphQL と <a href="https://github.com/graphql/graphiql">GraphiQL</a> ハンドラをセットアップする <a href="https://github.com/graphql-rust/juniper/blob/master/juniper_rocket/examples/rocket_server.rs">example</a> が含まれています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iron"><a class="header" href="#iron">Iron</a></h1>
<p><a href="https://github.com/iron/iron">Iron</a>は、Rust界隈でしばらく前からあるライブラリですが、最近はあまり開発されていません。とはいえ、Rust の安定版チャンネルで動作する、おなじみのリクエスト/レスポンス/ミドルウェアのアーキテクチャを持つ堅実なライブラリであることに変わりはありません。</p>
<p>JuniperのIronの統合は <code>juniper_iron</code> クレートに含まれています。</p>
<pre><code class="language-toml">[dependencies]
juniper = &quot;0.15.7&quot;
juniper_iron = &quot;0.7.4&quot;
</code></pre>
<p>ソースには、基本的な GraphQL と <a href="https://github.com/graphql/graphiql">GraphiQL</a> ハンドラをセットアップする <a href="https://github.com/graphql-rust/juniper_iron/blob/master/examples/iron_server.rs">example</a> が含まれています。</p>
<h2 id="基本的な統合"><a class="header" href="#基本的な統合">基本的な統合</a></h2>
<p>まずは最小限のスキーマで、GraphQLエンドポイントだけを立ち上げてみましょう。mount]を使用して、<code>/graphql</code>にGraphQLハンドラをアタッチします。</p>
<p>context_factory` 関数はリクエストごとに実行され、データベース接続のセットアップ、クッキーからのセッショントークン情報の読み取り、スキーマが必要とするその他のグローバルデータのセットアップに使用されます。</p>
<p>この例では、グローバルデータを使用しないので、単に空の値を返します。</p>
<pre><code class="language-rust ignore">extern crate juniper;
extern crate juniper_iron;
extern crate iron;
extern crate mount;

use mount::Mount;
use iron::prelude::*;
use juniper::EmptyMutation;
use juniper_iron::GraphQLHandler;

fn context_factory(_: &amp;mut Request) -&gt; IronResult&lt;()&gt; {
    Ok(())
}

struct Root;

#[juniper::graphql_object]
impl Root {
    fn foo() -&gt; String {
        &quot;Bar&quot;.to_owned()
    }
}

<span class="boring">#[allow(unreachable_code, unused_variables)]
</span>fn main() {
    let mut mount = Mount::new();

    let graphql_endpoint = GraphQLHandler::new(
        context_factory,
        Root,
        EmptyMutation::&lt;()&gt;::new(),
    );

    mount.mount(&quot;/graphql&quot;, graphql_endpoint);

    let chain = Chain::new(mount);

<span class="boring">  return;
</span>    Iron::new(chain).http(&quot;0.0.0.0:8080&quot;).unwrap();
}
</code></pre>
<h2 id="リクエストからデータにアクセスする"><a class="header" href="#リクエストからデータにアクセスする">リクエストからデータにアクセスする</a></h2>
<p>フィールドリゾルバからリクエストのソースIPアドレスなどにアクセスしたい場合は、Juniperの<a href="servers/../types/objects/using_contexts.html">コンテキスト機能</a>を使用してこのデータを渡す必要があります。</p>
<pre><code class="language-rust ignore"><span class="boring">extern crate juniper;
</span><span class="boring">extern crate juniper_iron;
</span><span class="boring">extern crate iron;
</span><span class="boring">use iron::prelude::*;
</span>use std::net::SocketAddr;

struct Context {
    remote_addr: SocketAddr,
}

impl juniper::Context for Context {}

fn context_factory(req: &amp;mut Request) -&gt; IronResult&lt;Context&gt; {
    Ok(Context {
        remote_addr: req.remote_addr
    })
}

struct Root;

#[juniper::graphql_object(
    Context = Context,
)]
impl Root {
    field my_addr(context: &amp;Context) -&gt; String {
        format!(&quot;Hello, you're coming from {}&quot;, context.remote_addr)
    }
}

<span class="boring">fn main() {
</span><span class="boring">    let _graphql_endpoint = juniper_iron::GraphQLHandler::new(
</span><span class="boring">        context_factory,
</span><span class="boring">        Root,
</span><span class="boring">        juniper::EmptyMutation::&lt;Context&gt;::new(),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hyper"><a class="header" href="#hyper">Hyper</a></h1>
<p><a href="https://hyper.rs/">Hyper</a>は、他の多くのRustウェブフレームワークが利用している高速なHTTP実装です。tokioランタイムによる非同期I/Oを提供し、Rustの安定したチャンネルで動作します。</p>
<p>Hyperは上位のWebフレームワークではないので、シンプルなエンドポイントルーティング、HTTPレスポンスの組み込み、再利用可能なミドルウェアなどの人間工学的な機能は含まれていません。GraphQLの場合、すべてのPOSTとGETは通常、いくつかの明確に定義されたレスポンスペイロードを持つ単一のエンドポイントを通過するため、これらは大きな欠点ではありません。</p>
<p>JuniperのHyper統合は、<a href="https://github.com/graphql-rust/juniper/tree/master/juniper_hyper"><code>juniper_hyper</code></a>クレートに含まれています。</p>
<pre><code class="language-toml">[dependencies]
juniper = &quot;0.15.7&quot;
juniper_hyper = &quot;0.8.0&quot;
</code></pre>
<p>ソースには、基本的な GraphQL と <a href="https://github.com/graphql/graphiql">GraphiQL</a> ハンドラをセットアップする <a href="https://github.com/graphql-rust/juniper/blob/master/juniper_hyper/examples/hyper_server.rs">example</a> が含まれています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="サードパーティとの連携"><a class="header" href="#サードパーティとの連携">サードパーティとの連携</a></h1>
<p>これらの例は、Juniperの開発者によって公式にメンテナンスされているわけではありません。</p>
<ul>
<li><a href="https://github.com/actix/examples/tree/HEAD/graphql/juniper">Actix Web</a> | <a href="https://github.com/actix/examples/tree/HEAD/graphql/juniper-advanced">Actix Web (advanced)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高度なトッピク"><a class="header" href="#高度なトッピク">高度なトッピク</a></h1>
<p>以下の章では、より高度なシナリオをいくつか紹介します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="イントロスペクション"><a class="header" href="#イントロスペクション">イントロスペクション</a></h1>
<p>GraphQLは<code>__schema</code>という特別な組み込みトップレベルフィールドを定義しています。このフィールドを問い合わせることで、実行時に <a href="https://graphql.org/learn/introspection/">スキーマをイントロスペクトする</a> ことができ、GraphQL サーバーがどのようなクエリや変異をサポートしているかを確認することができます。</p>
<p>イントロスペクションクエリは通常のGraphQLクエリーに過ぎないため、Juniperはネイティブでサポートしています。たとえば、サポートされているすべての型の名前を取得するには、Juniperに対して次のクエリを実行します。</p>
<pre><code class="language-graphql">{
  __schema {
    types {
      name
    }
  }
}
</code></pre>
<h2 id="スキーマイントロスペクションのjsonでの出力"><a class="header" href="#スキーマイントロスペクションのjsonでの出力">スキーマイントロスペクションのJSONでの出力</a></h2>
<p>GraphQLエコシステムの多くのクライアントライブラリやツールは、サーバースキーマの完全な表現を必要とします。多くの場合、この表現は JSON であり、<code>schema.json</code> と呼ばれます。スキーマの完全な表現は、特別に細工された introspection クエリを発行することで作成できます。</p>
<p>Juniperはスキーマ全体をイントロスペクトする便利な関数を提供しています。結果はJSONに変換され、<a href="https://github.com/graphql-rust/graphql-client">graphql-client</a>などのツールやライブラリで使用することができます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">extern crate juniper;
</span><span class="boring">extern crate serde_json;
</span>use juniper::{
    graphql_object, EmptyMutation, EmptySubscription, FieldResult, 
    GraphQLObject, IntrospectionFormat,
};

// スキーマを定義する.

#[derive(GraphQLObject)]
struct Example {
  id: String,
}

struct Context;
impl juniper::Context for Context {}

struct Query;

#[graphql_object(context = Context)]
impl Query {
   fn example(id: String) -&gt; FieldResult&lt;Example&gt; {
       unimplemented!()
   }
}

type Schema = juniper::RootNode&lt;
    'static, 
    Query, 
    EmptyMutation&lt;Context&gt;, 
    EmptySubscription&lt;Context&gt;
&gt;;

fn main() {
    // コンテキストオブジェクトを作成する.
    let ctx = Context{};

    // 組み込みのイントロスペクション・クエリを実行する.
    let (res, _errors) = juniper::introspect(
        &amp;Schema::new(Query, EmptyMutation::new(), EmptySubscription::new()),
        &amp;ctx,
        IntrospectionFormat::default(),
    ).unwrap();

    // イントロスペクションの結果をjsonに変換する.
    let json_result = serde_json::to_string_pretty(&amp;res);
    assert!(json_result.is_ok());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="非構造体オブジェクト"><a class="header" href="#非構造体オブジェクト">非構造体オブジェクト</a></h1>
<p>これまで、構造体とGraphQLオブジェクトのマッピングについてだけ見てきました。しかし、どんなRust型でもGraphQLオブジェクトにマッピングすることが可能です。この章では、列挙型を取り上げますが、traitも同様に使えます。</p>
<p><code>Result</code> ライクな列挙型を使用することで、例えば変異による検証エラーなどを報告するのに便利です。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::{graphql_object, GraphQLObject};
</span><span class="boring">#[derive(juniper::GraphQLObject)] struct User { name: String }
</span><span class="boring">
</span>#[derive(GraphQLObject)]
struct ValidationError {
    field: String,
    message: String,
}

<span class="boring">#[allow(dead_code)]
</span>enum SignUpResult {
    Ok(User),
    Error(Vec&lt;ValidationError&gt;),
}

#[graphql_object]
impl SignUpResult {
    fn user(&amp;self) -&gt; Option&lt;&amp;User&gt; {
        match *self {
            SignUpResult::Ok(ref user) =&gt; Some(user),
            SignUpResult::Error(_) =&gt; None,
        }
    }

    fn error(&amp;self) -&gt; Option&lt;&amp;Vec&lt;ValidationError&gt;&gt; {
        match *self {
            SignUpResult::Ok(_) =&gt; None,
            SignUpResult::Error(ref errors) =&gt; Some(errors)
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>ここでは、ユーザーの入力データが有効かどうかを判断するためにenumを使用しており、例えばサインアップミューテーションの結果として使用することができます。</p>
<p>これはGraphQLオブジェクトを表現するのに構造体以外を使用する方法の例ですが、「予想される」エラー（検証エラーのようなエラー）に対するエラー処理を実装する方法の例でもあります。GraphQLでエラーをどのように表現するかについて明確なルールはありませんが、GraphQLの著者の一人が「ハード」フィールドエラーの使用方法と、期待されるエラーのモデル化方法について<a href="https://github.com/facebook/graphql/issues/117#issuecomment-170180628">いくつか</a> <a href="https://github.com/graphql/graphql-js/issues/560#issuecomment-259508214">コメント</a>を発表しています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="暗黙的および明示的なnull"><a class="header" href="#暗黙的および明示的なnull">暗黙的および明示的なNULL</a></h1>
<p>クライアントがクエリでNullの引数やフィールドを送信するには、2つの方法があります。</p>
<p>私たちは NULL リテラルを使用することができます。</p>
<pre><code class="language-graphql">{
    field(arg: null)
}
</code></pre>
<p>あるいは、単に論点を省略することもできます。</p>
<pre><code class="language-graphql">{
    field
}
</code></pre>
<p>前者は明示的なNULL、後者は暗黙的なNULLです。</p>
<p>ユーザーがどちらを提供したかを知っておくと便利な場面もあります。</p>
<p>例えば、あなたのビジネスロジックに、ユーザーが自分自身に対してパッチ操作を行うための関数があるとします。ユーザーは、オプションで好きな番号と嫌いな番号を持つことができ、そのための入力は次のようになるとします。</p>
<pre><pre class="playground"><code class="language-rust">/// ユーザー属性を更新します. None になっているフィールドはそのままです.
pub struct UserPatch {
    /// もし Some ならば、ユーザのお気に入り番号を更新する.
    pub favorite_number: Option&lt;Option&lt;i32&gt;&gt;,

    /// もし Some ならば、ユーザの一番好きな番号を更新する.
    pub least_favorite_number: Option&lt;Option&lt;i32&gt;&gt;,
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>ユーザーの好きな数字を 7 に設定するには、<code>favorite_number</code> を <code>Some(Some(7))</code> に設定します。GraphQLでは、このようになります。</p>
<pre><code class="language-graphql">mutation { patchUser(patch: { favoriteNumber: 7 }) }
</code></pre>
<p>ユーザーのお気に入り番号を解除するには、 <code>favorite_number</code> を <code>Some(None)</code> に設定します。GraphQL では、このようになります。</p>
<pre><code class="language-graphql">mutation { patchUser(patch: { favoriteNumber: null }) }
</code></pre>
<p>もし、ユーザーのお気に入り番号をそのままにしておきたい場合は、<code>None</code>に設定することになります。GraphQLでは、次のようになります。</p>
<pre><code class="language-graphql">mutation { patchUser(patch: {}) }
</code></pre>
<p>最後の2つのケースは、明示的なNULLと暗黙的なNULLを区別できるかどうかにかかっています。</p>
<p>Juniperでは、これは <code>Nullable</code> 型を使用して行うことができます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>use juniper::{FieldResult, Nullable};

#[derive(juniper::GraphQLInputObject)]
struct UserPatchInput {
    pub favorite_number: Nullable&lt;i32&gt;,
    pub least_favorite_number: Nullable&lt;i32&gt;,
}

impl Into&lt;UserPatch&gt; for UserPatchInput {
    fn into(self) -&gt; UserPatch {
        UserPatch {
            // 明示的な関数は、ビジネスロジック層が期待するように Nullable を Option&lt;Option&lt;T&gt;&gt; に変換します。
            favorite_number: self.favorite_number.explicit(),
            least_favorite_number: self.least_favorite_number.explicit(),
        }
    }
}

<span class="boring">pub struct UserPatch {
</span><span class="boring">    pub favorite_number: Option&lt;Option&lt;i32&gt;&gt;,
</span><span class="boring">    pub least_favorite_number: Option&lt;Option&lt;i32&gt;&gt;,
</span><span class="boring">}
</span>
<span class="boring">struct Session;
</span><span class="boring">impl Session {
</span><span class="boring">    fn patch_user(&amp;self, _patch: UserPatch) -&gt; FieldResult&lt;()&gt; { Ok(()) }
</span><span class="boring">}
</span>
struct Context {
    session: Session,
}
impl juniper::Context for Context {}

struct Mutation;

#[juniper::graphql_object(context = Context)]
impl Mutation {
    fn patch_user(ctx: &amp;Context, patch: UserPatchInput) -&gt; FieldResult&lt;bool&gt; {
        ctx.session.patch_user(patch.into())?;
        Ok(true)
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>この型は <code>Option</code> とよく似た機能を持ちますが、2つの空のバリアントを持っているので、暗黙的なヌルと明示的なヌルを区別することができます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="オブジェクトとジェネリクス"><a class="header" href="#オブジェクトとジェネリクス">オブジェクトとジェネリクス</a></h1>
<p>GraphQLとRustが異なるもうひとつのポイントは、ジェネリックの仕組みです。Rustでは、ほとんどすべての型がジェネリックになり得ます。つまり、型パラメータを取ります。GraphQLでは、リストと非Nullableの2つしかジェネリック型がありません。</p>
<p>このため、RustからGraphQLで公開できるものに制限があります。ジェネリックな構造体は公開できず、すべての型パラメータはバインドされなければなりません。例えば、<code>Result&lt;T, E&gt;</code> などは GraphQL 型にできませんが、<code>Result&lt;User, String&gt;</code> などは GraphQL 型にすることができます。</p>
<p><a href="advanced/non_struct_objects.html">前章</a>の実装をもう少しコンパクトに、しかし汎用的にしてみましょう。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">#[derive(juniper::GraphQLObject)] struct User { name: String }
</span><span class="boring">#[derive(juniper::GraphQLObject)] struct ForumPost { title: String }
</span>
#[derive(juniper::GraphQLObject)]
struct ValidationError {
    field: String,
    message: String,
}

<span class="boring">#[allow(dead_code)]
</span>struct MutationResult&lt;T&gt;(Result&lt;T, Vec&lt;ValidationError&gt;&gt;);

#[juniper::graphql_object(
    name = &quot;UserResult&quot;,
)]
impl MutationResult&lt;User&gt; {
    fn user(&amp;self) -&gt; Option&lt;&amp;User&gt; {
        self.0.as_ref().ok()
    }

    fn error(&amp;self) -&gt; Option&lt;&amp;Vec&lt;ValidationError&gt;&gt; {
        self.0.as_ref().err()
    }
}

#[juniper::graphql_object(
    name = &quot;ForumPostResult&quot;,
)]
impl MutationResult&lt;ForumPost&gt; {
    fn forum_post(&amp;self) -&gt; Option&lt;&amp;ForumPost&gt; {
        self.0.as_ref().ok()
    }

    fn error(&amp;self) -&gt; Option&lt;&amp;Vec&lt;ValidationError&gt;&gt; {
        self.0.as_ref().err()
    }
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>ここでは、 <code>Result</code> のラッパーを作成し、 <code>Result&lt;T, E&gt;</code> の具体的なインスタンスを個別の GraphQL オブジェクトとして公開しています。このラッパーが必要な理由は、Rustのトレイトを派生させる際のルールにあります。この場合、 <code>Result</code> と Juniper の内部 GraphQL トレイトは、どちらもサードパーティから取得したものです。</p>
<p>ジェネリックスを使用しているので、インスタンス化された型の名前も指定する必要があります。仮にJuniperがその名前を理解できたとしても、 <code>MutationResult&lt;User&gt;</code> は有効なGraphQLの型名ではありません。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1回のリクエストで複数の操作を行う"><a class="header" href="#1回のリクエストで複数の操作を行う">1回のリクエストで複数の操作を行う</a></h1>
<p>GraphQL標準では、一般に、実行したいクライアント操作（クエリーやミューテーションなど）ごとに1回のサーバーリクエストがあることを想定しています。これは概念的には単純ですが、非効率になる可能性があります。</p>
<p><a href="https://www.apollographql.com/docs/link/links/batch-http.html">apollo-link-batch-http</a>のようないくつかのクライアントライブラリは、1つのHTTPリクエストでバッチ処理を行う機能を追加し、ネットワークのラウンドトリップを節約し、パフォーマンスを向上させる可能性を持っています。リクエストをバッチ処理する前に考慮すべきいくつかの <a href="https://blog.apollographql.com/batching-client-graphql-queries-a685f5bcd41b">トレードオフ</a> があります。</p>
<p>Juniperのサーバー統合クレートは、JSON配列を使用して、1つのHTTPリクエストで複数の操作をサポートしています。このため、特別な設定なしにバッチ処理をサポートするクライアントライブラリとの互換性があります。</p>
<p>他社が保守するサーバー統合クレートは、バッチ要求をサポートする必要はありません。バッチリクエストは公式のGraphQL仕様の一部ではありません。</p>
<p>統合がバッチリクエストをサポートしていると仮定して、以下のようなGraphQLクエリについて。</p>
<pre><code class="language-graphql">{
  hero {
    name
  }
}
</code></pre>
<p>個々のリクエストに対してサーバーにPOSTするjsonデータは、次のようになります。</p>
<pre><code class="language-json">{
  &quot;query&quot;: &quot;{hero{name}}&quot;
}
</code></pre>
<p>そしてその応答は、このような形になります。</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;hero&quot;: {
      &quot;name&quot;: &quot;R2-D2&quot;
    }
  }
}
</code></pre>
<p>1回のHTTPリクエストで同じクエリを2回実行したい場合、サーバーにPOSTするjsonデータのバッチは次のようになります。</p>
<pre><code class="language-json">[
  {
    &quot;query&quot;: &quot;{hero{name}}&quot;
  },
  {
    &quot;query&quot;: &quot;{hero{name}}&quot;
  }
]
</code></pre>
<p>そしてその応答は、このような形になります。</p>
<pre><code class="language-json">[
  {
    &quot;data&quot;: {
      &quot;hero&quot;: {
        &quot;name&quot;: &quot;R2-D2&quot;
      }
    }
  },
  {
    &quot;data&quot;: {
      &quot;hero&quot;: {
        &quot;name&quot;: &quot;R2-D2&quot;
      }
    }
  }
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="データローダーによるn1問題の回避"><a class="header" href="#データローダーによるn1問題の回避">データローダーによるN+1問題の回避</a></h1>
<p>Graphqlサーバーに共通する問題は、リゾルバがデータソースに問い合わせる方法です。
この問題により、不必要なデータベースクエリーやhttpリクエストが大量に発生します。
例えば、あるカルト宗教に属する人々をリストアップしたいとします。</p>
<pre><code class="language-graphql">query {
  persons {
    id
    name
    cult {
      id
      name
    }
  }
}
</code></pre>
<p>SQLデータベースで実行されるのは、次のようなものでしょう。</p>
<pre><code class="language-sql">SELECT id, name, cult_id FROM persons;
SELECT id, name FROM cults WHERE id = 1;
SELECT id, name FROM cults WHERE id = 1;
SELECT id, name FROM cults WHERE id = 1;
SELECT id, name FROM cults WHERE id = 1;
SELECT id, name FROM cults WHERE id = 2;
SELECT id, name FROM cults WHERE id = 2;
SELECT id, name FROM cults WHERE id = 2;
# ...
</code></pre>
<p>ユーザーのリストが返されると、各ユーザーのカルトを検索するために別のクエリーが実行されます。
これはすぐに問題になることがおわかりいただけると思います。</p>
<p>これに対する一般的な解決策は、<strong>dataloader</strong> を導入することです。
これはJuniperで<a href="https://github.com/cksac/dataloader-rs">cksac/dataloader-rs</a>というクレートを使って行うことができ、キャッシュ型と非キャッシュ型の2種類のdataloaderを持っています。</p>
<h4 id="キャッシュローダー"><a class="header" href="#キャッシュローダー">キャッシュローダー</a></h4>
<p><code>DataLoader</code>はメモ化キャッシュを提供します。与えられたキーで<code>.load()</code>が一度呼ばれた後、結果の値は冗長なロードを排除するためにキャッシュされます。</p>
<p><code>DataLoader</code>のキャッシュは、RedisやMemcache、その他のアプリケーションレベルの共有キャッシュを置き換えるものではありません。<code>DataLoader</code>は、何よりもまずデータロードのメカニズムであり、そのキャッシュは、アプリケーションへの単一のリクエストのコンテキストで同じデータを繰り返しロードしないという目的を果たすだけです。<a href="https://github.com/graphql/dataloader#caching">(続きを読む)</a></p>
<h3 id="どのようなものですか"><a class="header" href="#どのようなものですか">どのようなものですか？</a></h3>
<pre><code class="language-toml">[dependencies]
actix-identity = &quot;0.4.0-beta.4&quot;
actix-rt = &quot;1.0&quot;
actix-web = {version = &quot;2.0&quot;, features = []}
juniper = { git = &quot;https://github.com/graphql-rust/juniper&quot; }
futures = &quot;0.3&quot;
postgres = &quot;0.15.2&quot;
dataloader = &quot;0.12.0&quot;
async-trait = &quot;0.1.30&quot;
</code></pre>
<pre><code class="language-rust  ignore">// use dataloader::cached::Loader;
use dataloader::non_cached::Loader;
use dataloader::BatchFn;
use std::collections::HashMap;
use postgres::{Connection, TlsMode};
use std::env;

pub fn get_db_conn() -&gt; Connection {
    let pg_connection_string = env::var(&quot;DATABASE_URI&quot;).expect(&quot;need a db uri&quot;);
    println!(&quot;Connecting to {}&quot;, pg_connection_string);
    let conn = Connection::connect(&amp;pg_connection_string[..], TlsMode::None).unwrap();
    println!(&quot;Connection is fine&quot;);
    conn
}

#[derive(Debug, Clone)]
pub struct Cult {
  pub id: i32,
  pub name: String,
}

pub fn get_cult_by_ids(hashmap: &amp;mut HashMap&lt;i32, Cult&gt;, ids: Vec&lt;i32&gt;) {
  let conn = get_db_conn();
  for row in &amp;conn
    .query(&quot;SELECT id, name FROM cults WHERE id = ANY($1)&quot;, &amp;[&amp;ids])
    .unwrap()
  {
    let cult = Cult {
      id: row.get(0),
      name: row.get(1),
    };
    hashmap.insert(cult.id, cult);
  }
}

pub struct CultBatcher;

#[async_trait]
impl BatchFn&lt;i32, Cult&gt; for CultBatcher {

    // 各オリジナルキーと カルト を対応させた配列を返す必要があるため、ハッシュマップを使用します.
    async fn load(&amp;self, keys: &amp;[i32]) -&gt; HashMap&lt;i32, Cult&gt; {
        println!(&quot;load cult batch {:?}&quot;, keys);
        let mut cult_hashmap = HashMap::new();
        get_cult_by_ids(&amp;mut cult_hashmap, keys.to_vec());
        cult_hashmap
    }
}

pub type CultLoader = Loader&lt;i32, Cult, CultBatcher&gt;;

// 新規にローダーを作成する.
pub fn get_loader() -&gt; CultLoader {
    Loader::new(CultBatcher)
      // 通常、DataLoaderは、実行中の1フレーム内で発生する個々のロードをすべてまとめ、要求されたすべてのキーでバッチ関数を呼び出します.
      // しかし、この動作が好ましくない、あるいは最適でない場合があります.
      // おそらく、リクエストはその後の数回のティックに分散されることを想定しているのでしょう.
      // See: https://github.com/cksac/dataloader-rs/issues/12 
      // More info: https://github.com/graphql/dataloader#batch-scheduling 
      // Yield Countが大きいと、より多くのリクエストをバッチに追加できますが、実際にロードされるまでの待ち時間が長くなります.
      .with_yield_count(100)
}

#[juniper::graphql_object(Context = Context)]
impl Cult {
  //  あなたのリゾルバ

  // データローダを呼び出す.
  pub async fn cult_by_id(ctx: &amp;Context, id: i32) -&gt; Cult {
    ctx.cult_loader.load(id).await
  }
}

</code></pre>
<h3 id="どうやって呼び出すのですか"><a class="header" href="#どうやって呼び出すのですか">どうやって呼び出すのですか？</a></h3>
<p>データローダを作成すると、非同期関数 <code>.load()</code> と <code>.load_many()</code> を持つようになります。
上記の例では、 <code>cult_loader.load(id: i32).await</code> が <code>Cult</code> を返します。もし <code>cult_loader.load_many(Vec&lt;i32&gt;).await</code> を使用していれば、 <code>Vec&lt;Cult&gt;</code> を返していたことでしょう。</p>
<h3 id="データローダーはどこで作成するのですか"><a class="header" href="#データローダーはどこで作成するのですか">データローダーはどこで作成するのですか？</a></h3>
<p>データローダーは、あるユーザーが他のユーザーから認証された範囲外のキャッシュ/バッチデータをロードできるバグのリスクを回避するために、リクエストごとに作成する必要があります。
個々のリゾルバ内にデータローダを作成すると、バッチ処理の発生が妨げられ、 データローダの利点が損なわれることになります。</p>
<p>例えば、<em>あなたのコンテキストを宣言するとき</em></p>
<pre><code class="language-rust  ignore">use juniper;

#[derive(Clone)]
pub struct Context {
    pub cult_loader: CultLoader,
}

impl juniper::Context for Context {}

impl Context {
    pub fn new(cult_loader: CultLoader) -&gt; Self {
        Self {
            cult_loader
        }
    }
}
</code></pre>
<p><em>GraphQLのハンドラ(注意：ここでコンテキストをインスタンス化すると、リクエストごとに保持されます)</em></p>
<pre><code class="language-rust  ignore">pub async fn graphql(
    st: web::Data&lt;Arc&lt;Schema&gt;&gt;,
    data: web::Json&lt;GraphQLRequest&gt;,
) -&gt; Result&lt;HttpResponse, Error&gt; {

    // コンテキストの設定.
    let cult_loader = get_loader();
    let ctx = Context::new(cult_loader);

    // 実行.
    let res = data.execute(&amp;st, &amp;ctx).await; 
    let json = serde_json::to_string(&amp;res).map_err(error::ErrorInternalServerError)?;

    Ok(HttpResponse::Ok()
        .content_type(&quot;application/json&quot;)
        .body(json))
}
</code></pre>
<h3 id="さらなる例"><a class="header" href="#さらなる例">さらなる例</a></h3>
<p><code>Dataloaders</code> と <code>Context</code> を使った完全な例は <a href="https://github.com/jayy-lmao/rust-graphql-docker">jayy-lmao/rust-graphql-docker</a> を参照してください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="サブスクリプション"><a class="header" href="#サブスクリプション">サブスクリプション</a></h1>
<h3 id="graphqlサブスクリプションでリアルタイムデータを実現する方法"><a class="header" href="#graphqlサブスクリプションでリアルタイムデータを実現する方法">GraphQLサブスクリプションでリアルタイムデータを実現する方法</a></h3>
<p>GraphQLサブスクリプションは、サーバーからリアルタイムのメッセージを要求するクライアントに対して、サーバーからデータをプッシュする方法です。サブスクリプションは、クライアントに配信するフィールドのセットを指定するという点でクエリーと似ていますが、1つの回答をすぐに返すのではなく、サーバーで特定のイベントが発生するたびに結果が送信されます。</p>
<p>サブスクリプションを実行するには、コーディネーター（接続を生成するもの）と、ストリームに解決できるGraphQLオブジェクトが必要です。<a href="https://github.com/graphql-rust/juniper/tree/master/juniper_subscriptions"><code>juniper_subscriptions</code></a>クレートは、デフォルトの接続実装を提供します。現在、サブスクリプションは <code>master</code> ブランチでのみサポートされています。以下を <code>Cargo.toml</code> に追加してください。</p>
<pre><code class="language-toml">[dependencies]
juniper = { git = &quot;https://github.com/graphql-rust/juniper&quot;, branch = &quot;master&quot; }
juniper_subscriptions = { git = &quot;https://github.com/graphql-rust/juniper&quot;, branch = &quot;master&quot; }
</code></pre>
<h3 id="スキーマ定義"><a class="header" href="#スキーマ定義">スキーマ定義</a></h3>
<p><code>Subscription</code> は単なる GraphQL オブジェクトで、<a href="advanced/../schema/schemas_and_mutations.html">Schema</a> でオペレーション用に定義したクエリールートやミューテーションオブジェクトと同じものです。サブスクリプションでは、すべてのフィールド/オペレーションは非同期でなければならず、<a href="https://docs.rs/futures/0.3.4/futures/stream/trait.Stream.html">Stream</a>を返す必要があります。</p>
<p>この例では、2つのイベント、文字列 <code>Hello</code> と <code>World!</code> を順次返すサブスクリプションオペレーションを示しています。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use juniper::{graphql_object, graphql_subscription, FieldError};
</span><span class="boring">use futures::Stream;
</span><span class="boring">use std::pin::Pin;
</span><span class="boring">
</span><span class="boring">#[derive(Clone)]
</span><span class="boring">pub struct Database;
</span><span class="boring">impl juniper::Context for Database {}
</span>
<span class="boring">pub struct Query;
</span><span class="boring">#[graphql_object(context = Database)]
</span><span class="boring">impl Query {
</span><span class="boring">   fn hello_world() -&gt; &amp;'static str {
</span><span class="boring">       &quot;Hello World!&quot;
</span><span class="boring">   }
</span><span class="boring">}
</span>pub struct Subscription;

type StringStream = Pin&lt;Box&lt;dyn Stream&lt;Item = Result&lt;String, FieldError&gt;&gt; + Send&gt;&gt;;

#[graphql_subscription(context = Database)]
impl Subscription {
    async fn hello_world() -&gt; StringStream {
        let stream = futures::stream::iter(vec![
            Ok(String::from(&quot;Hello&quot;)),
            Ok(String::from(&quot;World!&quot;))
        ]);
        Box::pin(stream)
    }
}
<span class="boring">
</span><span class="boring">fn main () {}
</span></code></pre></pre>
<h3 id="コーディネーター"><a class="header" href="#コーディネーター">コーディネーター</a></h3>
<p>サブスクリプションは、通常のクエリよりも少し多くのリソースを必要とし、DOS攻撃の大きなベクトルを提供します。これは、正しく処理されないと、サーバを簡単にダウンさせることができます。<a href="https://docs.rs/juniper_subscriptions/0.15.0/trait.SubscriptionCoordinator.html"><code>SubscriptionCoordinator</code></a> トレイトは、DOS 攻撃の緩和やリソース制限などの機能を有効にするための調整ロジックを提供します。</p>
<p><a href="https://docs.rs/juniper_subscriptions/0.15.0/trait.SubscriptionCoordinator.html"><code>SubscriptionCoordinator</code></a> はスキーマを含み、開いた接続を追跡し、サブスクリプションの開始と終了を処理し、それぞれのサブスクリプションに対してグローバルなサブスクリプション ID を維持することができます。接続が確立されるたびに、<a href="https://docs.rs/juniper_subscriptions/0.15.0/trait.SubscriptionCoordinator.html"><code>SubscriptionCoordinator</code></a> は <a href="https://docs.rs/juniper_subscriptions/0.15.0/trait.SubscriptionConnection.html"><code>SubscriptionConnection</code></a> を生成します。<a href="https://docs.rs/juniper_subscriptions/0.15.0/trait.SubscriptionConnection.html"><code>SubscriptionConnection</code></a> は単一の接続を処理し、クライアントストリーム用のリゾルバロジックと再接続およびシャットダウンロジックを提供します。</p>
<p><a href="https://docs.rs/juniper_subscriptions/0.15.0/trait.SubscriptionCoordinator.html"><code>SubscriptionCoordinator</code></a> は自分で実装することもできますが、Juniper には <a href="https://docs.rs/juniper_subscriptions/0.15.0/struct.Coordinator.html"><code>Coordinator</code></a> というシンプルで汎用的な実装が用意されています。ここで、<a href="https://docs.rs/juniper_subscriptions/0.15.0/struct.Connection.html"><code>Connection</code></a> は操作によって返される値の <code>Stream</code> で、<a href="https://docs.rs/juniper/0.14.2/juniper/enum.GraphQLError.html"><code>GraphQLError</code></a> は購読が失敗した場合のエラーです。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">extern crate futures;
</span><span class="boring">extern crate juniper;
</span><span class="boring">extern crate juniper_subscriptions;
</span><span class="boring">extern crate serde_json;
</span><span class="boring">extern crate tokio;
</span><span class="boring">use juniper::{
</span><span class="boring">    http::GraphQLRequest,
</span><span class="boring">    graphql_object, graphql_subscription, 
</span><span class="boring">    DefaultScalarValue, EmptyMutation, FieldError, 
</span><span class="boring">    RootNode, SubscriptionCoordinator,
</span><span class="boring">};
</span><span class="boring">use juniper_subscriptions::Coordinator;
</span><span class="boring">use futures::{Stream, StreamExt};
</span><span class="boring">use std::pin::Pin;
</span><span class="boring">
</span><span class="boring">#[derive(Clone)]
</span><span class="boring">pub struct Database;
</span><span class="boring">
</span><span class="boring">impl juniper::Context for Database {}
</span><span class="boring">
</span><span class="boring">impl Database {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        Self {}
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Query;
</span><span class="boring">
</span><span class="boring">#[graphql_object(context = Database)]
</span><span class="boring">impl Query {
</span><span class="boring">    fn hello_world() -&gt; &amp;'static str {
</span><span class="boring">        &quot;Hello World!&quot;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Subscription;
</span><span class="boring">
</span><span class="boring">type StringStream = Pin&lt;Box&lt;dyn Stream&lt;Item = Result&lt;String, FieldError&gt;&gt; + Send&gt;&gt;;
</span><span class="boring">
</span><span class="boring">#[graphql_subscription(context = Database)]
</span><span class="boring">impl Subscription {
</span><span class="boring">    async fn hello_world() -&gt; StringStream {
</span><span class="boring">        let stream =
</span><span class="boring">            futures::stream::iter(vec![Ok(String::from(&quot;Hello&quot;)), Ok(String::from(&quot;World!&quot;))]);
</span><span class="boring">        Box::pin(stream)
</span><span class="boring">    }
</span><span class="boring">}
</span>type Schema = RootNode&lt;'static, Query, EmptyMutation&lt;Database&gt;, Subscription&gt;;

fn schema() -&gt; Schema {
    Schema::new(Query {}, EmptyMutation::new(), Subscription {})
}

async fn run_subscription() {
    let schema = schema();
    let coordinator = Coordinator::new(schema);
    let req: GraphQLRequest&lt;DefaultScalarValue&gt; = serde_json::from_str(
        r#&quot;{
            &quot;query&quot;: &quot;subscription { helloWorld }&quot;
        }&quot;#,
    )
        .unwrap();
    let ctx = Database::new();
    let mut conn = coordinator.subscribe(&amp;req, &amp;ctx).await.unwrap();
    while let Some(result) = conn.next().await {
        println!(&quot;{}&quot;, serde_json::to_string(&amp;result).unwrap());
    }
}
<span class="boring">
</span><span class="boring">fn main() { }
</span></code></pre></pre>
<h3 id="web統合とその事例"><a class="header" href="#web統合とその事例">Web統合とその事例</a></h3>
<p>現在、<a href="https://github.com/graphql-rust/juniper/tree/master/juniper_warp">warp</a>を使ったサブスクリプションの例がありますが、まだαの状態です。
<a href="https://github.com/apollographql/subscriptions-transport-ws/blob/master/PROTOCOL.md">WS</a>上のGraphQLはまだ完全にサポートされておらず、非標準的です。</p>
<ul>
<li><a href="https://github.com/graphql-rust/juniper/tree/master/examples/warp_subscriptions">Warp Subscription Example</a></li>
<li><a href="https://github.com/graphql-rust/juniper/tree/master/examples/basic_subscriptions">Example</a></li>
</ul>
<!-- TODO: juniper_subscriptionsのドキュメントが定義されている場合、これらのリンクを修正する. --->
<!--- --->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
