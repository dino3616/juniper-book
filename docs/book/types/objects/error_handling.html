<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>エラーハンドリング - Juniper - GraphQL Server for Rust 日本語版</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../introduction.html"><strong aria-hidden="true">1.</strong> はじめに</a></li><li class="chapter-item expanded "><a href="../../quickstart.html"><strong aria-hidden="true">2.</strong> クイックスタート</a></li><li class="chapter-item expanded "><a href="../../types/index.html"><strong aria-hidden="true">3.</strong> 型システム</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../types/objects/defining_objects.html"><strong aria-hidden="true">3.1.</strong> オブジェクトの定義</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../types/objects/complex_fields.html"><strong aria-hidden="true">3.1.1.</strong> 複雑なフィールド</a></li><li class="chapter-item expanded "><a href="../../types/objects/using_contexts.html"><strong aria-hidden="true">3.1.2.</strong> コンテキストを使う</a></li><li class="chapter-item expanded "><a href="../../types/objects/error_handling.html" class="active"><strong aria-hidden="true">3.1.3.</strong> エラーハンドリング</a></li></ol></li><li class="chapter-item expanded "><a href="../../types/other-index.html"><strong aria-hidden="true">3.2.</strong> その他の型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../types/enums.html"><strong aria-hidden="true">3.2.1.</strong> 列挙型</a></li><li class="chapter-item expanded "><a href="../../types/interfaces.html"><strong aria-hidden="true">3.2.2.</strong> インターフェイス</a></li><li class="chapter-item expanded "><a href="../../types/input_objects.html"><strong aria-hidden="true">3.2.3.</strong> 入力オブジェクト</a></li><li class="chapter-item expanded "><a href="../../types/scalars.html"><strong aria-hidden="true">3.2.4.</strong> スカラー</a></li><li class="chapter-item expanded "><a href="../../types/unions.html"><strong aria-hidden="true">3.2.5.</strong> ユニオン</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../schema/schemas_and_mutations.html"><strong aria-hidden="true">4.</strong> スキーマとミューテーション</a></li><li class="chapter-item expanded "><a href="../../servers/index.html"><strong aria-hidden="true">5.</strong> サーバーを追加する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../servers/official.html"><strong aria-hidden="true">5.1.</strong> Juniperによる連携</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../servers/warp.html"><strong aria-hidden="true">5.1.1.</strong> Warp</a></li><li class="chapter-item expanded "><a href="../../servers/rocket.html"><strong aria-hidden="true">5.1.2.</strong> Rocket</a></li><li class="chapter-item expanded "><a href="../../servers/iron.html"><strong aria-hidden="true">5.1.3.</strong> Iron</a></li><li class="chapter-item expanded "><a href="../../servers/hyper.html"><strong aria-hidden="true">5.1.4.</strong> Hyper</a></li></ol></li><li class="chapter-item expanded "><a href="../../servers/third_party.html"><strong aria-hidden="true">5.2.</strong> サードパーティとの連携</a></li></ol></li><li class="chapter-item expanded "><a href="../../advanced/index.html"><strong aria-hidden="true">6.</strong> 高度なトッピク</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../advanced/introspection.html"><strong aria-hidden="true">6.1.</strong> イントロスペクション</a></li><li class="chapter-item expanded "><a href="../../advanced/non_struct_objects.html"><strong aria-hidden="true">6.2.</strong> 非構造体オブジェクト</a></li><li class="chapter-item expanded "><a href="../../advanced/implicit_and_explicit_null.html"><strong aria-hidden="true">6.3.</strong> 暗黙的および明示的なNULL</a></li><li class="chapter-item expanded "><a href="../../advanced/objects_and_generics.html"><strong aria-hidden="true">6.4.</strong> オブジェクトとジェネリクス</a></li><li class="chapter-item expanded "><a href="../../advanced/multiple_ops_per_request.html"><strong aria-hidden="true">6.5.</strong> 1回のリクエストで複数の操作を行う</a></li><li class="chapter-item expanded "><a href="../../advanced/dataloaders.html"><strong aria-hidden="true">6.6.</strong> データローダーによるN+1問題の回避</a></li><li class="chapter-item expanded "><a href="../../advanced/subscriptions.html"><strong aria-hidden="true">6.7.</strong> サブスクリプション</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Juniper - GraphQL Server for Rust 日本語版</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="エラーハンドリング"><a class="header" href="#エラーハンドリング">エラーハンドリング</a></h1>
<p>GraphQLにおけるエラー処理は、複数の方法で行うことができます。以下では、2つの異なるエラー処理モデルについて説明します。フィールドの結果とGraphQLスキーマの裏付けとなるエラーです。それぞれのアプローチには利点があります。正しいエラー処理方法を選択することは、アプリケーションの要件に依存します。両方のアプローチを調査することは有益です。</p>
<h2 id="フィールドの結果"><a class="header" href="#フィールドの結果">フィールドの結果</a></h2>
<p>Rustはエラーを処理する方法を2つ提供しています。回復可能なエラーには <code>Result&lt;T, E&gt;</code> を、回復不可能なエラーには <code>panic!</code> を使用します。Juniperはパニックに対して何もしません。パニックは周囲のフレームワークにバブルアップされ、うまくいけばそこで処理されます。</p>
<p>回復可能なエラーの場合、Juniperは組み込みの <code>Result</code> 型でうまく動作し、 <code>?</code> 演算子を使用することで、一般的に期待通りの動作をします。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span>use std::{
    str,
    path::PathBuf,
    fs::{File},
    io::{Read},
};
use juniper::{graphql_object, FieldResult};

struct Example {
    filename: PathBuf,
}

#[graphql_object]
impl Example {
    fn contents(&amp;self) -&gt; FieldResult&lt;String&gt; {
        let mut file = File::open(&amp;self.filename)?;
        let mut contents = String::new();
        file.read_to_string(&amp;mut contents)?;
        Ok(contents)
    }

    fn foo() -&gt; FieldResult&lt;Option&lt;String&gt;&gt; {
        // 一部無効なバイトがあります.
        let invalid = vec![128, 223];

        Ok(Some(str::from_utf8(&amp;invalid)?.to_string()))
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><code>FieldResult&lt;T&gt;</code> は <code>Result&lt;T, FieldError&gt;</code> のエイリアスで、すべてのフィールドが返さなければならないエラータイプです。演算子 <code>?</code> や <code>try!</code> マクロを使用すると、 <code>Display</code> トレイトを実装した型 (世の中のほとんどのエラータイプ) は、それらのエラーが自動的に <code>FieldError</code> に変換されます。</p>
<h2 id="エラーペイロードnullおよび部分エラー"><a class="header" href="#エラーペイロードnullおよび部分エラー">エラーペイロード、NULL、および部分エラー</a></h2>
<p>Juniperのエラー動作は、<a href="https://spec.graphql.org/June2018/#sec-Errors-and-Non-Nullability">GraphQL仕様</a>に準拠しています。</p>
<p>フィールドがエラーを返すと、フィールドの結果は <code>null</code> に置き換えられ、レスポンスのトップレベルに <code>errors</code> オブジェクトが追加で作成され、実行が再開されます。例えば、先ほどの例と以下のようなクエリの場合、</p>
<pre><code class="language-graphql">{
  example {
    contents
    foo
  }
}
</code></pre>
<p>もし <code>str::from_utf8</code> が <code>std::str::Utf8Error</code> を発生させた場合は、以下のような結果が返ります。</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;example&quot;: {
      contents: &quot;&lt;Contents of the file&gt;&quot;,
      foo: null
    }
  },
  &quot;errors&quot;: [
    &quot;message&quot;: &quot;invalid utf-8 sequence of 2 bytes from index 0&quot;,
    &quot;locations&quot;: [{ &quot;line&quot;: 2, &quot;column&quot;: 4 }])
  ]
}
</code></pre>
<p>上記の例のように、NULL でないフィールドからエラーが返された場合、 <code>null</code> 値は最初に NULL にできる親フィールドまで伝搬され、NULL にできるフィールドがない場合はルートの <code>data</code> オブジェクトに伝搬されます。</p>
<p>例えば、以下のようなクエリの場合です。</p>
<pre><code class="language-graphql">{
  example {
    contents
  }
}
</code></pre>
<p>上記の <code>File::open()</code> が <code>std::io::ErrorKind::PermissionDenied</code> を返した場合、以下のような結果が得られます。</p>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    &quot;message&quot;: &quot;Permission denied (os error 13)&quot;,
    &quot;locations&quot;: [{ &quot;line&quot;: 2, &quot;column&quot;: 4 }])
  ]
}
</code></pre>
<h3 id="構造化されたエラー"><a class="header" href="#構造化されたエラー">構造化されたエラー</a></h3>
<p>時には、追加の構造化されたエラー情報をクライアントに返すことが望ましい場合があります。これは、<a href="https://docs.rs/juniper/latest/juniper/trait.IntoFieldError.html"><code>IntoFieldError</code></a> を実装することで実現可能です。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[macro_use] extern crate juniper;
</span><span class="boring">use juniper::{graphql_object, FieldError, IntoFieldError, ScalarValue};
</span><span class="boring">
</span>enum CustomError {
    WhateverNotSet,
}

impl&lt;S: ScalarValue&gt; IntoFieldError&lt;S&gt; for CustomError {
    fn into_field_error(self) -&gt; FieldError&lt;S&gt; {
        match self {
            CustomError::WhateverNotSet =&gt; FieldError::new(
                &quot;Whatever does not exist&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;NO_WHATEVER&quot;
                }),
            ),
        }
    }
}

struct Example {
    whatever: Option&lt;bool&gt;,
}

#[graphql_object]
impl Example {
    fn whatever(&amp;self) -&gt; Result&lt;bool, CustomError&gt; {
        if let Some(value) = self.whatever {
            return Ok(value);
        }
        Err(CustomError::WhateverNotSet)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>指定された構造化エラー情報は、<a href="https://facebook.github.io/graphql/June2018/#sec-Errors"><code>extensions</code></a>キーに含まれます。</p>
<pre><code class="language-json">{
  &quot;errors&quot;: [{
    &quot;message&quot;: &quot;Whatever does not exist&quot;,
    &quot;locations&quot;: [{&quot;line&quot;: 2, &quot;column&quot;: 4}],
    &quot;extensions&quot;: {
      &quot;type&quot;: &quot;NO_WHATEVER&quot;
    }
  }]
}
</code></pre>
<h2 id="graphqlのスキーマに裏付けられたエラー"><a class="header" href="#graphqlのスキーマに裏付けられたエラー">GraphQLのスキーマに裏付けられたエラー</a></h2>
<p>Rustのエラーのモデルは、GraphQLに適応することができます。Rust のパニックは <code>FieldError</code> に似ています。クエリ全体が中断され、(エラー関連情報を除いて)何も取り出せなくなります。</p>
<p>すべてのエラーがこのような厳密な処理を必要とするわけではありません。回復可能なエラーや部分的なエラーは、クライアントがインテリジェントに処理できるように GraphQL スキーマに入れることができます。</p>
<p>このアプローチを実装するには、すべてのエラーを2つのエラークラスに分割する必要があります。</p>
<ul>
<li>ユーザーが修正できないクリティカルなエラー(例：データベースエラー)</li>
<li>ユーザが修正可能な回復可能エラー(例：無効な入力データ)</li>
</ul>
<p>クリティカルなエラーは、リゾルバから <code>FieldErrors</code> (前のセクションで説明) として返される。非クリティカルなエラーは GraphQL スキーマの一部であり、クライアントによって優雅に処理することができます。Rustと同様に、GraphQLでもユニオンを使った同様のエラーモデルが可能です（Unionsを参照）。</p>
<h3 id="単純な入力検証の例"><a class="header" href="#単純な入力検証の例">単純な入力検証の例</a></h3>
<p>この例では、基本的な入力検証を GraphQL タイプで実装しています。問題のあるフィールド名を特定するために文字列が使用されています。特定のフィールドに対するエラーも文字列として返されます。この例では、文字列はサーバーサイドでローカライズされたエラーメッセージを含んでいます。しかし、一意の文字列識別子を返し、クライアントがローカライズされた文字列をユーザーに提示するようにすることも可能です。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::{graphql_object, GraphQLObject, GraphQLUnion};
</span><span class="boring">
</span>#[derive(GraphQLObject)]
pub struct Item {
    name: String,
    quantity: i32,
}

#[derive(GraphQLObject)]
pub struct ValidationError {
    field: String,
    message: String,
}

#[derive(GraphQLObject)]
pub struct ValidationErrors {
    errors: Vec&lt;ValidationError&gt;,
}

#[derive(GraphQLUnion)]
pub enum GraphQLResult {
    Ok(Item),
    Err(ValidationErrors),
}

pub struct Mutation;

#[graphql_object]
impl Mutation {
    fn addItem(&amp;self, name: String, quantity: i32) -&gt; GraphQLResult {
        let mut errors = Vec::new();

        if !(10 &lt;= name.len() &amp;&amp; name.len() &lt;= 100) {
            errors.push(ValidationError {
                field: &quot;name&quot;.to_string(),
                message: &quot;between 10 and 100&quot;.to_string()
            });
        }

        if !(1 &lt;= quantity &amp;&amp; quantity &lt;= 10) {
            errors.push(ValidationError {
                field: &quot;quantity&quot;.to_string(),
                message: &quot;between 1 and 10&quot;.to_string()
            });
        }

        if errors.is_empty() {
            GraphQLResult::Ok(Item { name, quantity })
        } else {
            GraphQLResult::Err(ValidationErrors { errors })
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>各関数は異なる戻り値の型を持ち、入力パラメータに応じて新しい結果型を必要とする場合があります。例えば、ユーザーを追加する場合は、<code>Ok(Item)</code>の代わりに <code>Ok(User)</code> というバリアントを含む新しい結果型を必要とします。</p>
<p>クライアントは、以下の例に示すように、変異のリクエストを送信し、その結果のエラーを処理することができます。</p>
<pre><code class="language-graphql">{
  mutation {
    addItem(name: &quot;&quot;, quantity: 0) {
      ... on Item {
        name
      }
      ... on ValidationErrors {
        errors {
          field
          message
        }
      }
    }
  }
}
</code></pre>
<p>この方法の有用な副次的効果は、部分的に成功したクエリーまたはミューテーションを持つことです。あるリゾルバーが失敗しても、成功したリゾルバーの結果は破棄されません。</p>
<h3 id="複雑な入力検証の例"><a class="header" href="#複雑な入力検証の例">複雑な入力検証の例</a></h3>
<p>文字列を使ってエラーを伝える代わりに、GraphQLの型システムを使って、より正確にエラーを記述することが可能です。</p>
<p>誤りやすい入力変数ごとに、GraphQLオブジェクトのフィールドが作成されます。そのフィールドは、その特定のフィールドに対するバリデーションが失敗した場合に設定されます。必要な型の数が以前より大幅に増えたため、繰り返しを減らすために何らかのコード生成が必要になると思われます。各リゾルバ関数はカスタム <code>ValidationResult</code> を持ち、その関数が提供するフィールドのみを含みます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::{graphql_object, GraphQLObject, GraphQLUnion};
</span><span class="boring">
</span>#[derive(GraphQLObject)]
pub struct Item {
    name: String,
    quantity: i32,
}

#[derive(GraphQLObject)]
pub struct ValidationError {
    name: Option&lt;String&gt;,
    quantity: Option&lt;String&gt;,
}

#[derive(GraphQLUnion)]
pub enum GraphQLResult {
    Ok(Item),
    Err(ValidationError),
}

pub struct Mutation;

#[graphql_object]
impl Mutation {
    fn addItem(&amp;self, name: String, quantity: i32) -&gt; GraphQLResult {
        let mut error = ValidationError {
            name: None,
            quantity: None,
        };

        if !(10 &lt;= name.len() &amp;&amp; name.len() &lt;= 100) {
            error.name = Some(&quot;between 10 and 100&quot;.to_string());
        }

        if !(1 &lt;= quantity &amp;&amp; quantity &lt;= 10) {
            error.quantity = Some(&quot;between 1 and 10&quot;.to_string());
        }

        if error.name.is_none() &amp;&amp; error.quantity.is_none() {
            GraphQLResult::Ok(Item { name, quantity })
        } else {
            GraphQLResult::Err(error)
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<pre><code class="language-graphql">{
  mutation {
    addItem {
      ... on Item {
        name
      }
      ... on ValidationErrorsItem {
        name
        quantity
      }
    }
  }
}
</code></pre>
<p>期待されるエラーはクエリ内部で直接処理されます。さらに、重要でないエラーはすべて、サーバとクライアントの両方が事前に知っています。</p>
<h3 id="重大なエラーを含む入力検証の例"><a class="header" href="#重大なエラーを含む入力検証の例">重大なエラーを含む入力検証の例</a></h3>
<p>これまでの例では、ノンクリティカルエラーしか含まれていませんでした。GraphQLスキーマの内部でエラーを提供することで、予期せぬクリティカルエラーが発生したときに、それを返すことができます。</p>
<p>以下の例では、理論上のデータベースが故障し、エラーを発生させる可能性があります。データベースが失敗することは一般的ではないので、対応するエラーはクリティカルエラーとして返されます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate juniper;
</span><span class="boring">
</span>use juniper::{graphql_object, graphql_value, FieldError, GraphQLObject, GraphQLUnion, ScalarValue};

#[derive(GraphQLObject)]
pub struct Item {
    name: String,
    quantity: i32,
}

#[derive(GraphQLObject)]
pub struct ValidationErrorItem {
    name: Option&lt;String&gt;,
    quantity: Option&lt;String&gt;,
}

#[derive(GraphQLUnion)]
pub enum GraphQLResult {
    Ok(Item),
    Err(ValidationErrorItem),
}

pub enum ApiError {
    Database,
}

impl&lt;S: ScalarValue&gt; juniper::IntoFieldError&lt;S&gt; for ApiError {
    fn into_field_error(self) -&gt; FieldError&lt;S&gt; {
        match self {
            ApiError::Database =&gt; FieldError::new(
                &quot;Internal database error&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;DATABASE&quot;
                }),
            ),
        }
    }
}

pub struct Mutation;

#[graphql_object]
impl Mutation {
    fn addItem(&amp;self, name: String, quantity: i32) -&gt; Result&lt;GraphQLResult, ApiError&gt; {
        let mut error = ValidationErrorItem {
            name: None,
            quantity: None,
        };

        if !(10 &lt;= name.len() &amp;&amp; name.len() &lt;= 100) {
            error.name = Some(&quot;between 10 and 100&quot;.to_string());
        }

        if !(1 &lt;= quantity &amp;&amp; quantity &lt;= 10) {
            error.quantity = Some(&quot;between 1 and 10&quot;.to_string());
        }

        if error.name.is_none() &amp;&amp; error.quantity.is_none() {
            Ok(GraphQLResult::Ok(Item { name, quantity }))
        } else {
            Ok(GraphQLResult::Err(error))
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h2 id="追加資料"><a class="header" href="#追加資料">追加資料</a></h2>
<p><a href="https://shopify.dev/docs/admin-api/graphql/reference">Shopify API</a>も同様のアプローチを実装しています。彼らのAPIは、実世界のアプリケーションでこのアプローチを探求するための良い参考となります。</p>
<h1 id="比較"><a class="header" href="#比較">比較</a></h1>
<p>上で説明した最初のアプローチ、つまりすべてのエラーが <code>FieldResult</code> で定義されたクリティカルエラーである場合、実装はより簡単です。しかし、クライアントはどのようなエラーが発生するのかを知らないので、代わりにエラー文字列から何が起こったのかを推測しなければなりません。これは脆弱で、クライアントやサーバーが変化することによって、時間の経過とともに変化する可能性があります。したがって、クライアントとサーバー間の暗黙の契約を維持するために、クライアントとサーバー間の広範な統合テストが必要とされます。</p>
<p>GraphQLスキーマにクリティカルでないエラーをエンコードすることで、クライアントとサーバーの間の契約を明示的にします。これにより、クライアントはこれらのエラーを理解して正しく処理することができ、サーバーは変更がクライアントを破壊する可能性があることを知ることができます。しかし、このエラー情報をGraphQLスキーマにエンコードするためには、追加のコードとノンクリティカルエラーの先行定義が必要です。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../types/objects/using_contexts.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../types/other-index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../types/objects/using_contexts.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../types/other-index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
